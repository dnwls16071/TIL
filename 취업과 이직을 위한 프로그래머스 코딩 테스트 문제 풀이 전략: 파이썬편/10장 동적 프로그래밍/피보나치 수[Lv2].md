### 📌문제 설명

피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.

예를들어

```
F(2) = F(0) + F(1) = 0 + 1 = 1
F(3) = F(1) + F(2) = 1 + 1 = 2
F(4) = F(2) + F(3) = 1 + 2 = 3
F(5) = F(3) + F(4) = 2 + 3 = 5
```
와 같이 이어집니다.

2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.

### 📌제한 조건

n은 2 이상 100,000 이하인 자연수입니다.

### 📌입출력 예

|n|return|
|:-----:|:-----:|
|3|2|
|5|5|

### 📌소스 코드

```python
import sys
sys.setrecursionlimit(10**6)

def fibo(n, dp):
    if n == 0:
        return 0
    elif n == 1 or n == 2:
        return 1
    
    if dp[n] == 0:
        dp[n] = fibo(n-1, dp) + fibo(n-2, dp)
    return dp[n] % 1234567
            
def solution(n):
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = dp[2] = 1
    return fibo(n, dp)
```

### 📌동적 프로그래밍의 접근법

[1]. 탑다운(Top-Down)

```
- 주어진 문제를 작은 단위의 문제로 계속해서 쪼개나간 뒤, 이 작은 문제를 바탕으로 다시 하나의 문제를 푸는 방식을 의미한다.
- 어떤 결과를 만들기 위해 그보다 더 작은 결과에서 필요한 값들을 하나씩 만들어가는 형식을 보여주며, 통상 재귀 형태로 구현된다.
- 이 방법은 재귀를 기반으로하므로 코드 자체는 이미 이전 값들이 모두 계산되어 있다는 전제 조건 하에서 이루어진다.
- 하지만 처음 실행할 때는 자신보다 작은 값에 대한 정보를 모르니 아는 값이 나올 때까지 점점 더 작은 단위로 실행된다.
- 이 과정을 계속 반복하면 어느 순간 작은 문제가 최선의 답이 나올 것이라고 가정하고 문제를 푸는 방식이다.
- 이미 작은 문제에 대한 답을 구했다면 계산을 거치지 않도록 해야 한다.
```

[2]. 바텀업(Bottom-Up)

```
- 반대로 주어진 문제를 작은 문제부터 풀고, 이 과정을 반복해서 알고 있는 정답을 늘려나감녀서 최종적으로는 원래 문제를 푸는 방식을 의미한다.
- 처음부터 알고 있는 값에서 시작하므로 다음 계산을 위해 중간 결과값을 저장해 사용하며 보통 반복문 형태로 구현된다.
```
