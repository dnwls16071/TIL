# 알리바바와 40인의 도둑

알리바바는 40인의 도둑으로부터 금화를 훔쳐 도망치고 있습니다.

알리바바는 도망치는 길에 평소에 잘 가지 않던 계곡의 돌다리로 도망가고자 한다.

계곡의 돌다리는 N×N개의 돌들로 구성되어 있다. 각 돌다리들은 높이가 서로 다릅니다.

해당 돌다리를 건널때 돌의 높이 만큼 에너지가 소비됩니다. 이동은 최단거리 이동을 합니다.

즉 현재 지점에서 오른쪽 또는 아래쪽으로만 이동해야 합니다.

N*N의 계곡의 돌다리 격자정보가 주어지면 (1, 1)격자에서 (N, N)까지 가는데 드는 에너지의

최소량을 구하는 프로그램을 작성하세요.

만약 N=3이고, 계곡의 돌다리 격자 정보가 다음과 같다면 

![캡처](https://github.com/dnwls16071/TIL/assets/106802375/4da4492d-d6b5-4fd5-9edf-9fea65744086)

(1, 1)좌표에서 (3, 3)좌표까지 가는데 드는 최소 에너지는 3+2+3+4+2=14이다.

## ▣ 입력설명

첫 번째 줄에는 자연수 N(1<=N<=20)이 주어진다.

두 번째 줄부터 계곡의 N*N 격자의 돌다리 높이(10보다 작은 자연수) 정보가 주어진다.

## ▣ 출력설명

첫 번째 줄에 (1, 1)출발지에서 (N, N)도착지로 가기 위한 최소 에너지를 출력한다.

## ▣ 입력예제 1

5

3 7 2 1 9

5 8 3 9 2

5 3 1 2 3

5 4 3 2 1

1 7 5 2 4

## ▣ 출력예제 1

25

▣ 첫 번째 풀이(Bottom-Up)

```python
import sys
input = sys.stdin.readline

N = int(input())
graph = [list(map(int, input().split())) for _ in range(N)]
dp = [[0] * N for _ in range(N)]
dp[0][0] = graph[0][0]

# 가장자리 → 행렬 그대로 일직선
for i in range(1, N):
    dp[i][0] = dp[i-1][0] + graph[i][0]
    dp[0][i] = dp[0][i-1] + graph[0][i]

for i in range(1, N):
    for j in range(1, N):
        dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + graph[i][j]
print(dp[N-1][N-1])
```

▣ 두 번째 풀이(Top-Down)

```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**6)

N = int(input())
graph = [list(map(int, input().split())) for _ in range(N)]
dp = [[0] * N for _ in range(N)]

def DFS(y, x):
    # 이미 계산된 적이 있다면?
    if dp[y][x] != 0:
        return dp[y][x]
    if y == 0 and x == 0:
        return graph[0][0]
    else:
        # 가로줄
        if y == 0:
            dp[y][x] = DFS(y, x-1) + graph[y][x]
        # 세로줄
        elif x == 0:
            dp[y][x] = DFS(y-1, x) + graph[y][x]
        else:
            dp[y][x] = min(DFS(y-1, x), DFS(y, x-1)) + graph[y][x]
        return dp[y][x]

print(DFS(N-1, N-1))
```

- 1행과 1열의 값은 누적합의 개념이기에 라인을 따라 더해준다.

- (1, 1)부터 왼쪽, 위의 dp테이블 값의 최솟값과 돌다리의 높이를 더해 초기화한다.

▣ 문제풀이 시간 : 20m

▣ 체감 난이도 : ★★
