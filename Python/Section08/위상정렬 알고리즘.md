# 위상정렬 알고리즘

위상정렬은 어떤 일을 하는 순서를 찾는 알고리즘입니다.

각각의 일의 선후관계가 복잡하게 얽혀있을 때 각각 일의 선후관계를 유지하면서 전체 일의 순서를 짜는 알고리즘입니다.

만약 아래와 같은 일의 순서를 각각 지키면서 전체 일의 순서를 정한다면

1 4 //1번일을 하고 난 후 4번일을 해야한다.

5 4

4 3

2 5

2 3

6 2

![캡처](https://github.com/dnwls16071/TIL/assets/106802375/7f5cdbe4-1a95-4c3c-9e27-3210894b030d)

전체 일의 순서는 1, 6, 2, 5, 4, 3과 같이 정할 수 있다. 전체 일의 순서는 여러 가지가 있습니다. 그 중에 하나입니다.

## ▣ 입력설명

첫 번째 줄에 전체 일의 개수 N과 일의 순서 정보의 개수 M이 주어집니다.

두 번째 줄부터 M개의 정보가 주어집니다.

## ▣ 출력설명

전체 일의 순서를 출력합니다.

## ▣ 입력예제 1

6 6

1 4

5 4

4 3

2 5

2 3

6 2

## ▣ 출력예제 1

1 6 2 5 4 3

▣ 첫 번째 풀이(1차원 dp테이블)

```python
import sys
input = sys.stdin.readline
from collections import deque

# N : 전체 일의 갯수
# M : 일의 순서 정보의 갯수
N, M = map(int, input().split())
# graph : 일의 선후관계를 나타낼 단방향 그래프
graph = [[0] * (N+1) for _ in range(N+1)]
# degree : 진입 차수를 나타내는 1차원 배열
degree = [0] * (N+1)
# 자료구조 큐
dQ = deque()

for i in range(M):
    # a번 작업 → b번 작업
    a, b = map(int, input().split())
    # a → b
    graph[a][b] = 1
    # b노드의 진입 차수 1만큼 증가
    degree[b] += 1

for i in range(1, N+1):
    # 진입 차수가 0이다? → 선행되는 작업이 없으므로 먼저 처리해도 무방한 작업들
    if degree[i] == 0:
        dQ.append(i)

while dQ:
    v = dQ.popleft()
    print(v, end=" ")
    # v라는 노드와 관계를 맺는 노드라면? → 진입 차수를 감소시킴
    for i in range(1, N+1):
        if graph[v][i] == 1:
            degree[i] -= 1
            # 진입 차수가 0이다? → 선행되는 작업이 없으므로 먼저 처리해도 무방한 작업들
            if degree[i] == 0:
                dQ.append(i)
```
