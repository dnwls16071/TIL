# 양팔저울

무게가 서로 다른 K개의 추와 빈 그릇이 있다. 모든 추의 무게는 정수이고, 그릇의 무게는 0으로 간주한다. 

양팔저울을 한 번만 이용하여 원하는 물의 무게를 그릇에 담고자 한다.

주어진 모든 추 무게의 합을 S라 하자. 예를 들어, 추가 3개이고, 각 추의 무게가 {1, 2, 6}이면, S=9이고, 양팔저울을 한 번만 이용하여 1부터 S사이에 대응되는 모든 무게의 물을 다음과 같이 그릇에 담을 수 있다. X는 그릇에 담는 물의 무게이고, ⎕은 그릇을 나타낸다.

![캡처](https://github.com/dnwls16071/TIL/assets/106802375/1e35d991-95d8-4585-ad2a-c7f1b5dec6e8)

만약 추의 무게가 {1, 5, 7}이면 S=13이고, 그릇에 담을 수 있는 물의 무게는 {1, 2, 3, 4, 5, 6, 7, 8, 11, 12, 13}이고, 1부터 S사이에서 무게에서 9와 10에 대응하는 무게의 물을 담을 수 없다.

K(3<=K<=13)개의 추 무게가 주어지면, 1부터 S사이의 정수 중 측정이 불가능한 물의 무게는 몇 가지가 있는 지 출력하는 프로그램을 작성하세요.

## ▣ 입력설명

첫 번째 줄에 자연수 K(3<=K<=13)이 주어집니다.

두 번째 줄에 K개의 각 추의 무게가 공백을 사이에 두고 주어집니다. 각 추의 무게는 1부터 200,000까지이다.

## ▣ 출력설명

첫 번째 측정이 불가능한 가지수를 출력하세요.

## ▣ 입력예제 1

3

1 5 7

## ▣ 출력예제 1

2

▣ 풀이

```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**6)

K = int(input())
weight = list(map(int, input().split()))
res = set()

def DFS(x, left, right):
    # 종료조건
    if x == K:
        if left > 0:
            res.add(left)
        if right > 0:
            res.add(right)
        if abs(right - left) > 0:
            res.add(abs(right - left))
    else:
        # 추를 왼쪽에 놓는 경우
        DFS(x+1, left+weight[x], right)
        # 추를 오른쪽에 놓는 경우
        DFS(x+1, left, right+weight[x])
        # 추를 사용 안하는 경우(추를 사용처리하고 양팔저울에 안 올린다)
        DFS(x+1, left, right)

DFS(0, 0, 0)
print(sum(weight) - len(res))
```

- 테스트케이스 예시로 이해하기

  - (1, 5, 7) 무게의 추가 존재하는 상황에서 왼쪽에 무게1의 추를 두고 오른쪽에 무게5의 추를 둔 상황에서 왼쪽에 물그릇을 놓으면 4kg의 무게를 측정할 수 있는 것이다.

- 또한 처음에 추를 사용하지 않는 경우를 `DFS(x, left, right)`로 두었는데 이 부분이 무한 루프를 유발하는 원인이 되었다.

- 왜냐하면 x 즉, 추의 개수가 증가하지 않으면 당연히 종료 조건에 도달조차 못하기 때문이다.

- 하지만 나는 이것을 생각하지 못했고 당연히 사용을 안하니까 증감변화없이 무심코 DFS를 돌렸는데 이것 때문에 시간이 오래 걸렸다.

▣ 문제풀이 시간 : 42m

▣ 체감 난이도 : ★★★★
