# 두 리스트 합치기

오름차순으로 정렬이 된 두 리스트가 주어지면 두 리스트를 오름차순으로 합쳐 출력하는 프로그램을 작성하세요.

## ▣ 입력설명

첫 번째 줄에 첫 번째 리스트의 크기 N(1<=N<=100)이 주어집니다.

두 번째 줄에 N개의 리스트 원소가 오름차순으로 주어집니다.

세 번째 줄에 두 번째 리스트의 크기 M(1<=M<=100)이 주어집니다.

네 번째 줄에 M개의 리스트 원소가 오름차순으로 주어집니다.

각 리스트의 원소는 int형 변수의 크기를 넘지 않습니다.

## ▣ 출력설명

오름차순으로 정렬된 리스트를 출력합니다.

## ▣ 입력예제 1

3

1 3 5

5

2 3 6 7 9

## ▣ 출력예제 1

1 2 3 3 5 6 7 9

▣ 풀이

```python
import sys
input = sys.stdin.readline

N = int(input())
array1 = list(map(int, input().split()))
M = int(input())
array2 = list(map(int, input().split()))

p1 = p2 = 0
answer = []
while True:
    if p1 == len(array1) or p2 == len(array2):
        break
    
    if array1[p1] > array2[p2]:
        answer.append(array2[p2])
        p2 += 1
    elif array1[p1] < array2[p2]:
        answer.append(array1[p1])
        p1 += 1
    else:
        answer.append(array1[p1])
        answer.append(array2[p2])
        p1 += 1
        p2 += 1

if p1 == len(array1):
    for i in range(p2, len(array2)):
        answer.append(array2[i])

if p2 == len(array2):
    for i in range(p1, len(array1)):
        answer.append(array1[i])
print(*answer)
```

- 투 포인터 활용

## ▣ 투 포인터(Two Pointer)

- 리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하는 포인터를 만들어 처리하는 알고리즘

- 정렬되어있는 두 리스트의 합집합에도 사용되며 병합 정렬(Merge Sort)의 정복(Counquer)의 기초가 되기도 함

## ▣ 슬라이딩 윈도우(Sliding Window)

- 윈도우(특정 범위)가 있을 때 윈도우 내부 요소의 값을 이용하여 문제를 풀이하는 알고리즘이다.

- 아래 그림을 참조하면 조금 더 쉽게 이해할 수 있다.

![캡처](https://github.com/dnwls16071/TIL/assets/106802375/578c4176-32db-482a-aa1e-24240128abc4)

- 예를 들어, [1, 3, 2, 6, -1, 4, 1, 8, 2]라는 배열이 있다고 가정하고 연속적인 5개의 숫자의 합이 최대인 경우의 최댓값을 구한다고 가정하자.

```python
numbers = [1, 3, 2, 6, -1, 4, 1, 8, 2]
n = len(numbers)
k = 5

window = sum(numbers[:k])
answer = window

for i in range(5, n):
  window += numbers[i] - numbers[i - k]
  answer = max(answer, window)
print(answer)
```

- 슬라이딩 윈도우는 고정적인 범위를 탐색할 때 유용합니다.

- 중복으로 연산을 제거하면서 효율을 높일 수 있다.

▣ 문제풀이 시간 : 14m

▣ 체감 난이도 : ★
