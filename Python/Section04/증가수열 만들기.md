# 증가수열 만들기

1부터 N까지의 모든 자연수로 구성된 길이 N의 수열이 주어집니다.

이 수열의 왼쪽 맨 끝 숫자 또는 오른쪽 맨 끝 숫자 중 하나를 가져와 나열하여 가장 긴 증가수열을 만듭니다. 

이때 수열에서 가져온 숫자(왼쪽 맨 끝 또는 오른쪽 맨 끝)는 그 수열에서 제거됩니다.

예를 들어 2 4 5 1 3 이 주어지면 만들 수 있는 가장 긴 증가수열의 길이는 4입니다.

맨 처음 왼쪽 끝에서 2를 가져오고, 그 다음 오른쪽 끝에서 3을 가져오고, 왼쪽 끝에서 4, 왼쪽 끝에서 5를 가져와 2 3 4 5 증가수열을 만들 수 있습니다.

## ▣ 입력설명

첫째 줄에 자연수 N(3<=N<=100)이 주어집니다.

두 번째 줄에 N개로 구성된 수열이 주어집니다.

## ▣ 출력설명

첫째 줄에 최대 증가수열의 길이를 출력합니다.

두 번째 줄에 가져간 순서대로 왼쪽 끝에서 가져갔으면 ‘L', 오른쪽 끝에서 가져갔으면 ’R'를 써간 문자열을 출력합니다.(단 마지막에 남은 값은 왼쪽 끝으로 생각합니다.)

## ▣ 입력예제 1

5

2 4 5 1 3

## ▣ 출력예제 1

4

LRLL

## ▣ 입력예제 2

10

3 2 10 1 5 4 7 8 9 6

## ▣ 출력예제 2

3

LRR

▣ 풀이

```python
import sys
input = sys.stdin.readline

N = int(input())
array = list(map(int, input().split()))

lp = 0
rp = N - 1
last = 0
temp = []
result = ""
while (lp <= rp):
    if array[lp] > last:
        temp.append([array[lp], "L"])
    if array[rp] > last:
        temp.append([array[rp], "R"])
    if len(temp) == 0:
        break
    else:
        temp.sort()
        last = temp[0][0]
        result += temp[0][1]
        if temp[0][1] == "L":
            lp += 1
        else:
            rp -= 1
        temp = []
print(len(result))
print(result)
```

- 간단한 문제라 풀이도 간단할 것 같았는데 풀이가 좀 답에 억지로 끼워맞춘 느낌이라 좋지 못한 코드라고 생각된다.

- 매번 `sort()`를 돌리면 그만큼 시간복잡도가 높아지지않을까 고민도 했지만 일단 이 풀이로 올리고 다른 풀이도 고민해봐야겠다.

▣ 문제풀이 시간 : 37m

▣ 체감 난이도 : ★★★
