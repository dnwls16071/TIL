## 목차

- 객체지향언어
   - [객체지향언어의 역사](#객체지향언어의-역사)
   - [객체지향언어](#객체지향언어)
- 클래스와 객체
   - [클래스와 객체의 정의와 용도](#클래스와-객체의-정의와-용도)
   - [객체와 인스턴스](#객체와-인스턴스)
   - [객체의 구성요소 - 속성과 기능)](#객체의-구성요소---속성과-기능)
   - [인스턴스의 생성과 사용](#인스턴스의-생성과-사용)
   - [객체 배열](#객체-배열)
- 변수와 메서드
   - [선언위치에 따른 변수의 종류](#선언위치에-따른-변수의-종류)
   - [클래스변수와 인스턴스 변수](#클래스변수와-인스턴스-변수)
   - [메서드](#메서드)
   - [메서드의 선언과 구현](#메서드의-선언과-구현)
   - [메서드의 호출](#메서드의-호출)
   - [return문](#return문)
   - [JVM의 메모리구조](#JVM의-메모리구조)
   - [기본형 매개변수와 참조형 매개변수](#기본형-매개변수와-참조형-매개변수)
   - [참조형 반환타입](#참조형-반환타입)
   - [재귀호출(recursive call)](#재귀호출recursive-call)
   - [클래스 메서드(static 메서드)와 인스턴스 메서드](#클래스-메서드static-메서드와-인스턴스-메서드)
   - [클래스 멤버와 인스턴스 멤버간의 참조와 호출](#클래스-멤버와-인스턴스-멤버간의-참조와-호출)
- 오버로딩(overloading)
   - [오버로딩이란?](#오버로딩이란)
   - [오버로딩의 조건](#오버로딩의-조건)
   - [오버로딩의 예](#오버로딩의-예)
   - [오버로딩의 장점](#오버로딩의-장점)
   - [가변인자와 오버로딩](#가변인자와-오버로딩)
- 생성자(constructor)
   - [생성자란?](#생성자란)
   - [기본 생성자(default constructor)](#기본-생성자default-constructor)
   - [매개변수가 있는 생성자](#매개변수가-있는-생성자)
   - [생성자에서 다른 생성자 호출하기 - this(), this](#생성자에서-다른-생성자-호출하기---this-this)
   - [생성자를 이용한 인스턴스의 복사](#생성자를-이용한-인스턴스의-복사)
- 변수의 초기화
   - [변수의 초기화](#변수의-초기화)
   - [명시적 초기화](#명시적-초기화)
   - [초기화 블럭](#초기화-블럭)
   - [멤버변수의 초기화 시기와 순서](#멤버변수의-초기화-시기와-순서)

---

## 객체지향언어의 역사

- 객체지향이론의 기본 개념은 '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.' 라는 것이다.

- 객체지향이론은 상속, 캡슐화, 추상화 개념을 중심으로 점차 구체적으로 발전

- 실제 사물의 속성과 기능을 분석한 다음, 데이터(변수)와 함수로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상 세계를 구현하고 이 가상세계에서 모의 실험을 함으로써 많은 시간과 비용을 절약

---

## 객체지향언어

- 객체지향언어의 주요 특징은 다음과 같다.

```bash
1. 코드의 재사용성이 높다.
- 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
2. 코드의 관리가 용이하다.
- 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
- 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.
```

---

## 클래스와 객체의 정의와 용도

- 클래스란 **객체를 정의해놓은 것** 또는 클래스는 **객체의 설계도 또는 틀**이라고 정의할 수 있다.

- 클래스는 객체를 생성하는데 사용되며, 객체는 클래스에 정의된 대로 생성된다.

```bash
- 클래스의 정의 : 클래스란 객체를 정의해 놓은 것이다.
- 클래스의 용도 : 클래스는 객체를 생성하는데 사용된다.
```

- 객체의 사전적인 정의는 **실제로 존재하는 것**이다. 우리가 주변에서 볼 수 있는 책상, 의자, 자동차와 같은 사물들이 곧 객체다.

```bash
- 객체의 정의 : 실제로 존재하는 것, 사물 또는 개념
- 객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름

- 유형의 객체 : 책상, 의자, 자동차, TV와 같은 사물
- 무형의 객체 : 수학 공식, 프로그램 에러와 같은 논리나 개념
```

- 클래스는 객체를 만드는데 사용될 뿐, 객체 그 자체는 아니다. 원하는 객체의 기능을 사용하기 위해서 클래스를 토대로 객체를 만들어야 하는 과정이 선행되어야 한다.

---

## 객체와 인스턴스

- 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.

```bash
클래스 -------→ 인스턴스(객체)

위의 과정을 "인스턴스화"라고 한다.
```

---

## 객체의 구성요소 - 속성과 기능

- 객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있으며, 일반적으로 객체는 다수의 속성과 기능을 갖는다.

- 즉, 객체는 속성과 기능의 집합이라고 할 수 있다.

- 객체가 가지고 있는 속성과 기능을 그 객체의 멤버라고 한다.

- 프로그래밍 관점에서 속성과 기능을 우리는 아래와 같이 정의할 것이다.

```bash
- 속성(property) : 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)
- 기능(function) : 메서드(method), 함수(function), 행위(behavior)
```

---

## 인스턴스의 생성과 사용

- Tv클래스를 선언 후 Tv인스턴스를 생성해 제품을 만들어보자.

```java
package codefactory;

class Tv {
    String color;
    boolean power;
    int channel;

    void power() {
        power = !power;
    }

    void channelUp() {
        ++channel;
    }

    void channelDown() {
        --channel;
    }
}

public class ex47 {
    public static void main(String[] args) {
        Tv tv = new Tv();

        // TV 전원을 켜기
        tv.power();

        // TV 채널의 번호를 10번으로 설정
        tv.channel = 10;
        System.out.println(tv.channel);

        // TV 채널의 번호 증가
        tv.channelUp();
        tv.channelUp();
        tv.channelUp();

        // 채널의 번호 증가시킨 후에 현재 채널읩 번호는?
        System.out.println(tv.channel);

        // TV 채널의 번호 감소
        tv.channelDown();
        tv.channelDown();
        tv.channelDown();

        // 채널의 번호 감소시킨 후에 현재 채널의 번호는?
        System.out.println(tv.channel);
    }
}
```

```java
Tv tv = new Tv();
```

- Tv클래스 타입의 참조변수 tv를 선언 후 객체를 생성한다.

- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.

  - Ex. 참조변수의 타입은 TV클래스, 인스턴스의 타입은 Tv클래스

```java
package codefactory;

public class ex48 {
    public static void main(String[] args) {
        Tv tv1 = new Tv();
        Tv tv2 = new Tv();

        System.out.println("tv1의 channel값은 " + tv1.channel + "입니다.");
        System.out.println("tv2의 channel값은 " + tv2.channel + "입니다.");

        tv1.channel = 10;
        tv2.channel = 20;

        System.out.println("tv1의 channel값은 " + tv1.channel + "입니다.");
        System.out.println("tv2의 channel값은 " + tv2.channel + "입니다.");
    }
}
```

- 같은 클래스(Tv클래스)로부터 생성되었을지라도 각 인스턴스의 속성(멤버변수)은 서로 다른 값을 유지할 수 있으며, 메서드의 내용은 모든 인스턴스에 대해 동일하다.

```java
package codefactory;

public class ex48 {
    public static void main(String[] args) {
        Tv tv1 = new Tv();
        Tv tv2 = new Tv();

        System.out.println("tv1의 channel값은 " + tv1.channel + "입니다.");
        System.out.println("tv2의 channel값은 " + tv2.channel + "입니다.");

        tv1.channel = 10;
        tv2.channel = 20;

        tv1 = tv2;

        System.out.println("tv1의 channel값은 " + tv1.channel + "입니다.");
        System.out.println("tv2의 channel값은 " + tv2.channel + "입니다.");
    }
}
```

```java
tv1 = tv2;
```

- tv1과 tv2는 모두 참조변수이므로, 각 인스턴스의 주소를 저장하고 있다.

- 위의 문장이 실행되면 tv1이 참조하는 인스턴스의 주소가 사라지게 되고 tv2가 참조하는 인스턴스의 주소가 tv1 인스턴스에 저장된다.

- 이 때, tv1과 tv2가 가리키는 주소가 같아지게 되고 기존에 tv1이 참조하던 참조변수의 객체는 그 누구에게도 참조를 받지 못하는 외톨이 신세가 된다.

- Java에서는 자신을 참조하고 있는 참조변수가 하나도 없는 인스턴스는 더 이상 사용되어질 수 없으므로 가비지 컬렉터(Garbage Colleector)에 의해서 자동적으로 메모리에서 제거된다.

- 하나의 인스턴스를 여러 참조 변수가 가리키는 것은 가능하지만 하나의 참조변수로 여러 개의 인스턴스를 가리키는 것은 불가능하다.

### 📌가비지 컬렉터(Garbage Collector)?

- Java나 Kotlin을 이용해 개발을 하다 보면 개발자가 메모리를 직접 해제해주는 일은 없다. 그 이유는 자바 가상 머신(JVM, Java Virtual Machine)의 가비지 컬렉터가 불필요한 메모리를 알아서 정리해주기 때문이다.

- 대신 Java에서 명시적으로 불필요한 데이터를 표현하기 위해서 일반적으로 null을 선언해준다.

---

## 객체 배열

- 많은 수의 객체를 다뤄야 할 때, 배열로 다루면 편리할 것이다. 객체 역시 배열로 다루는 것이 가능하며 이를 객체 배열이라고 한다.

- 그렇다고 __객체 배열 안에 객체가 저장되는 것은 아니고 객체의 주소가 저장된다.__

- 사실 객체 배열은 참조변수들을 하나로 묶은 참조변수 배열인 것이다.

```java
package codefactory;

public class ex49 {
    public static void main(String[] args) {
        Tv tv1 = new Tv();
        Tv tv2 = new Tv();
        Tv tv3 = new Tv();

        Tv[] TvArray = {tv1, tv2, tv3};

        for (int i = 0; i < TvArray.length; i++) {
            System.out.printf("TvArray[%d].channel = %d%n", i, TvArray[i].channel);
        }
    }
}
```

- 객체를 생성하는 부분에서 코드의 중복이 나타난다. 이를 해결하기 위해서 객체를 생성하는 부분에도 반복문을 적용한다.

- 객체를 생성하는 부분에서 객체 배열을 미리 선언 후 생성하게되는데 이 때, 크기를 미리 지정해야 한다.

```java
package codefactory;

public class ex49 {
    public static void main(String[] args) {
        Tv[] TvArray = new Tv[3];

        for (int i = 0; i < TvArray.length; i++) {
            TvArray[i] = new Tv();
        }

        for (int i = 0; i < TvArray.length; i++) {
            System.out.printf("TvArray[%d].channel = %d%n", i, TvArray[i].channel);
        }
    }
}
```

---

## 선언위치에 따른 변수의 종류

- 변수는 클래스 변수, 인스턴스 변수, 지역변수 모두 세 종류가 있다.

- 멤버 변수를 제외한 나머지 변수를 지역변수라고 하고 멤버변수 중 static이 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수이다.

| 변수의 종류 | 선언 위치 | 생성 시기 |
|--------|--------|--------|
| 클래스 변수(class variable) | 클래스 영역 | 클래스가 메모리에 올라갈 때 |
| 인스턴스 변수(instance variable) | 클래스 영역 | 인스턴스가 생성되었을 때 |
| 지역변수(local variable) | 클래스 영역 이외의 영역 | 변수 선언문이 수행되었을 때 |

__1. 인스턴스 변수(instance variable)__

- 클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다. 그렇기 때문에 인스턴스 변수의 값을 읽어 오거나 저장하기 위해서 먼저 인스턴스를 생성해야한다.

- 인스턴스는 독립적인 저장 공간을 가지므로 서로 다른 값을 가질 수 있다. 인스턴스마다 고유한 상태를 유지해야한다면 이는 인스턴스 변수로 선언해야 한다.

__2. 클래스 변수(class variable)__  

- 클래스 변수를 선언하는 방법은 인스턴스 변수 앞에 static을 붙이면 된다. 인스턴스마다 독립적인 저장공간을 갖는 인스턴스 변수와는 달리, 클래스 변수는 모든 인스턴스가 공통된 저장공간을 공유하게 된다.

- 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스 변수로 선언해야 한다.

- 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때까지 유지되며, public 접근 제어자를 붙이면 전역변수의 성격을 갖는다.

__3. 지역 변수(local variable)__

- 메서드 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.

---

## 클래스변수와 인스턴스변수

- 클래스변수와 인스턴스변수라는 것이 정확히 무엇인지 이해하기 위해서 카드를 예시로 들어보자.

```java
package codefactory;

class Card {
    static double height = 20.0;
    static double width = 10.0;

    String kind;
    int number;
}

public class ex50 {
    public static void main(String[] args) {
        Card card1 = new Card();
        Card card2 = new Card();

        card1.kind = "하트";
        card1.number = 8;

        System.out.println("카드의 모양은 " + card1.kind + "이고, 카드의 숫자는 " + card1.number + "이다.");
        System.out.println("카드의 높이 : " + Card.height);
        System.out.println("카드의 너비 : " + Card.width);

        card2.kind = "스페이드";
        card2.number = 2;

        System.out.println("카드의 모양은 " + card2.kind + "이고, 카드의 숫자는 " + card2.number + "이다.");
        System.out.println("카드의 높이 : " + Card.height);
        System.out.println("카드의 너비 : " + Card.width);

        Card.height = 10.0;
        Card.width = 5.0;
        System.out.println("엇... 카드의 높이가 " + Card.height + "으로 바뀌었고 카드의 너비는 " + Card.width + "으로 바뀌었네요?");

        System.out.println("카드의 모양은 " + card1.kind + "이고, 카드의 숫자는 " + card1.number + "이다.");
        System.out.println("카드의 높이 : " + Card.height);
        System.out.println("카드의 너비 : " + Card.width);

        card2.kind = "스페이드";
        card2.number = 2;

        System.out.println("카드의 모양은 " + card2.kind + "이고, 카드의 숫자는 " + card2.number + "이다.");
        System.out.println("카드의 높이 : " + Card.height);
        System.out.println("카드의 너비 : " + Card.width);
    }
}
```

- 각 Card 인스턴스는 자신만의 무늬(kind)와 숫자(number)를 유지하고 있어야 하므로 이들은 인스턴스 변수로 선언하고, 각 카드의 높이(height)와 너비(width)는 공통적으로 같은 값을 유지해야 한다.

- 카드의 높이나 너비와 같은 클래스 변수의 값을 바꾸려면 `클래스명.클래스변수`으로 접근해서 값을 바꿔야 한다.

- 쿨래스변수를 바꿀 때 `클래스명.클래스변수`의 형태로 하는 것이 좋은데 왜냐하면 인스턴스의 참조변수를 통해서 바꾸게 되면 해당 변수가 클래스변수가 아니라 인스턴스변수로 오해하기 쉽기 때문이다.

---

## 메서드




















