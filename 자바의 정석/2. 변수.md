## 목차

- 변수와 상수
   - [변수란?](#변수란)
   - [변수의 선언과 초기화](#변수의-선언과-초기화)  
   - [변수의 명명규칙](#변수의-명명규칙)  
- 변수의 타입  
   - [기본형(primitive)](#기본형primitive)
   - [상수와 리터럴(constant & literal)](#상수와-리터럴constant--literal)
   - [형식화된 출력 - printf()](#형식화된-출력---printf)
   - [화면에서 입력받기 - Scanner](#화면에서-입력받기---scanner)
- 기본형
   - [논리형 - boolean](#논리형---boolean)
   - [문자형 - char](#문자형---char)  
   - [정수형 - byte, short, int, long](#정수형---byte-short-int-long)  
   - [실수형 - float, double](#실수형---float-double)
- 형변환
   - [형변환](#형변환)
   - [형변환 방법](#형변환-방법)  
   - [정수형간의 형변환](#정수형간의-형변환)  
   - [실수형간의 형변환](#실수형간의-형변환)
   - [정수형과 실수형 간의 형변환](#정수형과-실수형-간의-형변환)
   - [묵시적 형변환](#묵시적-형변환)
   - [명시적 형변환](#명시적-형변환)
 
---

## 변수란?

- 프로그래밍 언어에서의 변수란, 값을 저장할 수 있는 메모리상의 공간을 의미한다.

- 변수란, 단 하나의 값만 저장할 수 있으므로 새로운 값을 저장하면 기존에 저장된 값은 사라지게 된다.

---

## 변수의 선언과 초기화

- 변수를 사용하려면 먼저 변수를 선언해야하는데, 변수의 선언 방법은 다음과 같다.

```java
int age;
```

- 위의 코드에서 `int`는 변수타입, `age`는 변수이름을 말한다.

- 저장하고자 하는 값의 종류에 맞게 변수의 타입을 선택해서 적어주면 된다.

- 메모리상의 공간에 존재하는 이들을 구별할 수 있어야 하는데 이를 위해 변수이름을 붙여 구별을 하게 된다.

---

## 변수의 초기화

- 변수를 선언(변수의 타입을 지정하고 변수의 이름을 지정)한 이후부터는 변수를 사용할 수 있으나, 그 전에 반드시 변수를 초기화해야 한다.

- 메모리는 여러 프로그램이 공유하는 자원으로 알 수 없는 값이 저장될 수 있기 때문에 오류를 사전에 방지하고자 초기화를 해야 한다.

- 초기화는 대입 연산자인 `=`를 사용하는데 수학에서의 대입 연산자는 양변이 같다는 뜻으로 쓰이지만 프로그래밍에서의 대입 연산자에서는 우변의 값을 좌변에 할당하라는 뜻으로 쓰인다.

```java
int age = 25;
```

--- 

## 변수의 명명규칙

- 개발은 팀 단위로 이루어지는 작업이다. 따라서 자신만이 알아볼 수 있는 변수명을 짓는 것보다는 개발자들끼리의 원활한 소통과 직관적인 이해를 위한 변수명을 짓는 연습을 할 필요가 있다.

- 변수명을 지을 때는 아래와 같은 규칙을 지켜야 한다.

```bash
1. 대소문자가 구분되며 길이에 제한이 없다.

2. 예약어를 사용해선 안 된다.

3. 숫자로 시작해서는 안 된다.

4. 특수문자는 "_"와 "$"만을 허용한다.
```

- 그 외에도 필수적인 것은 아니지만 권장되는 규칙들이 있어 이 부분도 고려할 필요가 있다.

```bash
1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
- 변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다.

2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 하는 낙타표기법을 적용한다.
- Ex. StringBuffer

3. 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우 "_"로 구분한다.
- Ex. PI, MAX_NUMBER
```

---

## 기본형(primitive)

- 자료형은 크게 "기본형"과 "참조형"으로 분류할 수 있다.

- 기본형 변수는 실제 값(data)을 저장하는 반면에 참조형 변수는 어떤 값이 저장되어 있는 주소(memory address)를 값으로 갖는다.

```java
int age = 25;

double height = 186.2;
```

- 기본형 변수의 경우 25와 186.2와 같이 data가 저장된다.

```java
Date date = new Date();
```

- 참조형 변수의 경우 Date 타입의 객체를 생성 후 그 생성된 주소를 date에 저장한다.

- 기본형은 모두 8개의 타입이 있으며 크게 논리형, 문자형, 정수형, 실수형으로 구분된다.

- 논리형

  - boolean으로 `true`와 `false` 중 하나를 값으로 가지며, 조건식과 논리적 계산에 사용된다.
 
- 문자형

  - char로 문자를 저장하는데 사용되며, 변수에 하나의 문자만 저장할 수 있다.
 
- 정수형

  - byte, short, int, long 등이 있으며 정수를 저장하는데 사용된다.
 
  - 주로 `int`와 `long`등을 사용하게 되고 값이 정말 커질 경우를 고려하면 `long`을 사용하면 된다.(실무에서는 20억을 기준으로 그 위까지 고려해야한다면 `long`을 아니면 `int`를 사용한다.)
 
- 실수형

  - float, double 등이 있으며 실수를 저장하는데 사용된다.
 
  - 주로 `double`이 사용된다.(실무에서도 `double` 사용을 권장한다.)
 
---

## 상수와 리터럴(constant & literal)

- 상수는 변수와 마찬가지로 값을 저장할 수 있는 공간이지만 변수와 달리 한 번 값을 저장하면 다른 값으로 변경할 수 없다.

- 상수를 선언할 때는 `final`키워드를 사용한다.

- `final`키워드는 "최종적인"이라는 뜻으로 한 번 값을 저장하면 다른 값으로 변경할 수 없고 재할당 역시 불가능하다.

```java
final int SPEED = 10;
```

- 그리고 상수는 선언과 동시에 반드시 초기화해야 하며, 그 후부터는 상수의 값을 변경하는 것이 허용되지 않는다.

```java
final int MAX_SPEED = 100;
```

- 위의 예시 코드를 보면 `SPEED`는 상수라는 것을 알 수 있고 `100`과 같이 그 자체로 값을 의미하는 것을 리터럴이라고 한다.

- 변수는 하나의 값을 저장할 수 있는 공간, 상수는 값을 한 번만 저장할 수 있는 공간, 리터럴은 그 자체로 값을 의미하는 것을 말한다.

---

## 형식화된 출력 - printf()

- `System.out.println()`으로 출력을 하게 되는데 이것 말고도 지시자를 미리 지정해 어떤 값을 형식에 맞게 출력하는 것이 가능한데 이를 `printf()`로 출력할 수 있다.

---

## 화면에서 입력받기 - Scanner

- 화면으로부터 값을 입력받으려면 Scanner 클래스를 이용한다.

```java
package codefactory;

import java.util.Scanner;

public class ex1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int x = scanner.nextInt();
        int y = scanner.nextInt();
        int z = x + y;
        System.out.println("x + y = " + z);
    }
}
```

```java
import java.util.Scanner;
```

- Scanner 클래스를 사용하려면 import를 해야한다.

```java
Scanner scanner = new Scanner(System.in);
```

- Scanner 클래스의 객체를 생성한다.

---

## 논리형 - boolean

- boolean형 변수에는 true와 false 중 하나를 저장할 수 있으며 기본값(default)은 false이다.

```java
boolean flag = false;
```

---

## 문자형 - char

- 문자형 역시 char의 한 가지 자료형밖에 없다. 문자를 저장하기 위한 변수를 선언할 때 사용하고 문자열이 아닌 단 하나의 문자만 저장한다는 것을 기억해야 한다.

```java
char gender = 'F';
```

- 위의 저장은 변수에 문자가 저장되는 것 같지만 사실은 문자가 아닌 문자의 유니코드(정수)가 저장된다.

- 문자를 숫자로 인코딩, 숫자를 문자로 디코딩할 수 있는 것이 유니코드의 개념이다.

## 정수형 - byte, short, int, long

- 정수형에는 4가지 자료형이 있으며 크기 순서대로 정렬하면 byte < short < int < long이다.

- 중요한 것만 짚고 넘어가자면 정수형 변수를 선언할 때는 `int`타입으로 해야 하고, `int`의 범위(약 ±20억)를 넘어서는 경우 `long`을 사용하면 된다.

- 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 오버플로우(overflow)라고 한다.

- 오버플로우가 발생했다고 해서 에러가 발생하는 것은 아니지만 개발자가 의도한 결과를 도출하지 못하게 된다. 이럴 때는 당황하지 않고 더 큰 자료형 타입을 고려하여 타입을 지정하면 된다.

---

## 실수형 - float, double

- 정밀도를 기준으로 보았을 때 `double`이 더 정확하다.

---

## 형변환

- 모든 변수와 리터럴에는 타입이 존재한다. 프로그램을 작성하다 보면 같은 타입과 다른 타입 간의 연산이 필요하다.

- 이럴 때는 연산을 수행하기 전에 타입을 일치시켜야 하는데, 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 형변환(casting)이라고 한다.

---

## 형변환 방법

- 형변환 방법은 아주 간단하다. 형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 소괄호와 함께 붙여주기만 하면 된다.

- 기본형 간의 형변환이나 참조형 간의 형변환은 가능하지만 기본형에서 참조형으로의 형변환은 불가능하다.

- 형변환의 경우 묵시적 형변환과 명시적 형변환이 존재하는데 이는 큰 타입에서 작은 타입으로의 변환이냐 작은 타입에서 큰 타입으로의 변환이냐에 따라 유지되는 부분이 있을수도 있고 소실되는 부분이 있을수도 있다.

---

## 정수형간의 형변환

- 우리가 큰 그릇에 들어있는 물을 작은 그릇으로 전부 옮기려고 할 때, 모든 물을 전부 옮길 수 없다.

- 프로그래밍에서도 마찬가지로 큰 타입에서 작은 타입으로의 변환, 예를 들어서 `int`타입을 `short`타입으로 변환하는 경우 값 손실(loss of data)이 발생할 수 있다.

```java
package codefactory;

public class ex2 {
    public static void main(String[] args) {
        int v1 = 100000000;
        short v2 = (short) v1;

        System.out.println(v2);
    }
}

// 실행 결과 : -7936
```

```java
package codefactory;

public class ex2 {
    public static void main(String[] args) {
        short v1 = 10;
        int v2 = v1;

        System.out.println(v2);
    }
}
```

- 반대로 작은 타입에서 큰 타입으로의 변환, 예를 들어서 `short`타입을 `int`타입으로 변환하는 경우 값 손실이 발생하지 않는다.

- 작은 그릇에 있는 몰을 큰 그릇으로 모두 옮기는게 가능하다는 것을 떠올리면 이해가 쉬울 것이다.

---

## 실수형간의 형변환

- 실수형에서 정수형간의 형변환과 같이 형 변환을 할 수 있다.

- 자바에서의 실수형 타입은 `float`, `double` 두 가지가 있는데 타입간의 관계는 float < double이다.

- 아래의 코드는 `float`에서 `double`로 즉, 작은 타입에서 큰 타입으로 형변환하는 코드의 예제다.

```java
package codefactory;

public class ex2 {
    public static void main(String[] args) {
        float v1 = 3.14f;
        double v2 = v1;

        System.out.println(v2);
    }
}
```

- 반대로 아래의 코드는 `double`에서 `float`으로 즉, 큰 타입에서 작은 타입으로 형변환하는 코드의 예제다.

```java
package codefactory;

public class ex2 {
    public static void main(String[] args) {
        double v1 = 3.1415926545;
        double v2 = (float) v1;

        System.out.println(v2);
    }
}

// 실행 결과 : 3.1415927410125732
```

---

## 정수형과 실수형 간의 형변환

- 정수형과 실수형은 저장 형식이 완전히 다르기 때문에 정수형간의 형변환처럼 간단히 값을 채우고 자르는 식으로 이루어지지 않는다.

- 기본적으로 실수형은 정수형보다 훨씬 큰 저장 범위를 갖기 때문에 정수형을 실수형으로 변환하는 것은 별 무리가 없다.

- 다만 실수형의 타입이 `float`이냐 `double`이냐에 따라 정밀도의 차이가 있어 약 ±20억의 범위를 갖는 `int`타입을 `float`타입으로 형변한하는 경우 정밀도의 제한으로 오차가 발생할 수 있다.

- 하지만 `double`타입으로 형변환하는 경우 오차없이 형변환이 가능하다.

```java
package codefactory;

public class ex2 {
    public static void main(String[] args) {
        int v1 = 900;
        double v2 = v1;

        System.out.println(v2);
    }
}

// 실행 결과 : 900.0
```

---

## 실수형을 정수형으로 형변환

- 실수형을 정수형으로 형변환하면 실수형의 소수점 이하 값들은 전부 버려진다.

- 정수형의 표현 형식으로 소수점 이하의 값을 표현할 수 없기 때문이다.

```java
package codefactory;

public class ex2 {
    public static void main(String[] args) {
        double v1 = 900.123456789;
        int v2 = (int) v1;

        System.out.println(v2);
    }
}

// 실행 결과 : 900(소수점 이하 소실)
```

---

## 묵시적 형변환

- 묵시적 형변환은 업캐스팅(Upcasting) 즉, 작은 범위에서 큰 범위로의 형변환을 말한다.

- 작은 타입에서 큰 타입으로의 형변환이 이루어지는 경우 소괄호와 함께 변환하고자 하는 타입을 명시하지 않아도 되기 때문에 암묵적 형변환이라고도 한다.

```java
package codefactory;

public class ex2 {
    public static void main(String[] args) {
        int v1 = 900;
        double v2 = v1;

        System.out.println(v2);
    }
}

// 실행 결과 : 900.0
```

- 위의 코드에서 `int`타입 변수 v1을 `double`타입으로 형변환을 하는 과정에서 소괄호와 함께 변환하고자 하는 타입을 명시하지 않은 것이 대표적인 업캐스팅 예시이다.

---

## 명시적 형변환

- 명시적 형변환은 다운캐스팅(Downcasting) 즉, 큰 범위에서 작은 범위로의 형변환을 말한다.

- 큰 타입에서 작은 타입으로의 형변환이 이루어지는 경우 소괄호와 함께 변환하고자 하는 타입을 반드시 명시해줘야 하기 때문에 명시적 형변환이라고 하는 것이다.

- 이 다운캐스팅은 개발자가 의도하여 작성이 되는 것으로 전적으로 모든 책임이 개발자에게 있으며, 값 손실의 우려가 있어 사용을 권장하지 않는다.

```java
package codefactory;

public class ex2 {
    public static void main(String[] args) {
        double v1 = 900.123456789;
        int v2 = (int) v1;

        System.out.println(v2);
    }
}

// 실행 결과 : 900(소수점 이하 소실)
```

