## 목차

- 연산자
   - [연산자와 피연산자](#연산자와-피연산자)
   - [식과 대입연산자](#식과-대입연산자)  
   - [연산자의 종류](#연산자의-종류)  
   - [연산자의 우선순위와 결합규칙](#연산자의-우선순위와-결합규칙)
   - [산술 변환](#산술-변환)
- 단항 연산자
   - [증감 연산자](#증감-연산자)  
   - [부호 연산자](#부호-연산자)  
- 산술 연산자
   - [사칙 연산자](#사칙-연산자)  
   - [나머지 연산자](#나머지-연산자)  
- 비교 연산자
   - [대소비교 연산자](#대소비교-연산자)  
   - [등가비교 연산자](#등가비교-연산자)  
- 논리 연산자
   - [논리 연산자](#논리-연산자)  
   - [비트 연산자](#비트-연산자)  
- 그 외의 연산자
   - [조건 연산자](#조건-연산자)  
   - [대입 연산자](#대입-연산자)

---

## 연산자와 피연산자

- 연산자는 연산을 수행하는 기호(+, -, /, *)를 말하고 피연산자는 연산자의 작업 대상(변수, 상수, 리터럴)을 말한다.

```java
x + 3
```

- 위의 예제 코드에서 `x`, `3`은 피연산자라고 하고 `+`를 연산자라고 하는 것이다.

---

## 식과 대입연산자

- 연산자와 피연산자를 조합하여 계산하고자하는 것을 표현한 것을 식(expression)이라고 한다.

```java
x + 3;
```

- 위의 예제 코드 `x + 3` 자체가 하나의 식이 되는 것이다.

- 작성한 식을 프로그램에 포함시키려면 식의 끝에 세미콜론을 붙여서 문장으로 만들어야 한다.

---

## 연산자의 종류

| 종류 | 연산자 | 설명 |
|-------|-----------|-------|
| 산술 연산자 | +, -, *, /, %, >>, << | 사칙 연산과 나머지 연산 |
| 비교 연산자 | <, >, <=, >=, ==, != | 크고 작음과 같고 다름을 비교 |
| 논리 연산자 | &&, \|\|, !, &, \|, ^, ~ | AND와 OR의 개념 |
| 대입 연산자 | = | 우변의 값을 좌변에 저장 |
| 기타 연산자 | (type), ?:, instanceof | 형변환 연산자, 삼항 연산자, instanceof 연산 |

* 실무에서도 모든 개발자들이 우선순위와 그런 것들을 외우면서 코딩하지 않고 그 때마다 찾아서 코드를 작성하는 경우가 많다고 하나 전체적인 개념은 아는 것이 좋을 것 같다.

--- 

## 연산자의 우선순위와 결합규칙

- 상식적으로 판단이 가능한 수준으로 주의해야 할 연산자 우선순위만 체크하고 넘어간다.

- 또한 대부분 괄호가 표시를 하지 않지만 우선순위가 헷갈린다면 명확하게 괄호로 결합규칙을 적용하는 것이 좋다.

---

## 산술 변환

- 앞서 정수형간의 형변환, 실수형간의 형변환, 정수형과 실수형간의 형변환 등에 대해 공부하면서 연산을 위해서는 같은 타입으로 맞춰주는 것이 필요하다는 것을 알고 있다.

```java
package codefactory;

public class ex3 {
    public static void main(String[] args) {
        int v1 = 100;
        float f1 = 100f;

        float f = v1 + f1;
        int i = v1 + (int) f1;

        System.out.println(f);
        System.out.println(i);
    }
}

// 실행 결과 f : 200.0
// 실행 결과 i : 200
```

- 기본적으로 실수형이 정수형보다 더 많은 범위의 수를 표현할 수 있다.

- 따라서 `float f = v1 + f1;` 부분은 `int → float`이기 때문에 묵시적 형변환이 발생하여 형변환 연산자를 생략할 수 있다.

- 하지만 `int i = v1 + (int) f1;` 부분은 `float → int`이기 때문에 명시적 형변환을 해주어야 하므로 반드시 `(int)`를 써줘야 한다.

---

## 증감 연산자

- 증감 연산자는 피연산자에 저장된 값을 1 증가 또는 감소시킨다. 증감 연산자의 피연산자로 정수와 실수가 모두 가능하지만 `final` 키워드를 통해 선언한 상수의 경우 값을 변경할 수 없어 상수에는 증감 연산자를 사용할 수 없다.

- 증감 연산자의 타입으로는 전위형(prefix), 후위형(postfix)가 있다.

| 타입 | 설명 | 사용 예 |
|-------|-------|-------|
| 전위형 | 값이 참조되기 전에 증가시킨다. | j = ++i; |
| 후위형 | 값이 참조된 후에 증가시킨다. | j = i++; |

```java
package codefactory;

public class ex4 {
    public static void main(String[] args) {
        int i = 5;

        i++;
        System.out.println(i);

        i = 5;

        ++i;
        System.out.println(i);
    }
}
```

- 위와 같이 증감 연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 사용된 경우 전위형과 후위형의 차이가 없다.

- 다른 수식에 포함되거나 메서드의 매개변수로 사용된 경우 즉, 단독으로 사용되지 않은 경우의 전위형과 후위형의 결과는 다르다.

```java
package codefactory;

public class ex5 {
    public static void main(String[] args) {
        int i = 5;
        int j = 0;

        j = ++i;
        System.out.println(i);
        System.out.println(j);

        i = 5;
        j = 0;

        j = i++;
        System.out.println(i);
        System.out.println(j);
    }
}
```

- 위의 부분에서는 변수 i의 값을 먼저 증가시킨 후 그 값을 변수 j에 할당했다. 따라서 변수 i, j의 값은 모두 6이 된다.

- 아래 부분에서는 변수 i의 값을 변수 j에 먼저 할당한 후 값을 증가했다. 따라서 변수 j는 5가 되고, 변수 i는 6이 되는 것이다.

---

## 부호 연산자

- 부호 연산자는 수학에서와 같이 더하고(+) 빼는(-) 연산을 수행하는 연산자이다. 기본형(primitive type)과 참조형(reference type)에 모두 사용할 수 없고 기본형에만 사용할 수 있다.

```java
package codefactory;

public class ex6 {
    public static void main(String[] args) {
        int v1 = 10;
        int v2 = 10;

        System.out.println(v1 + v2);
        System.out.println(v1 - v2);
    }
}
```

- 부호 연산자는 피연산자의 타입이 숫자와 관련된 것이어야 하므로 boolean형과 char형에선 사용을 제외한다.

- 수학에서의 연산과 동일한 방향을 가진다. 단 그 결과는 항상 수학에서의 연산과 같이 보장할 순 없는데 그것은 바로 자료형의 타입 때문이다.

```java
package codefactory;

public class ex8 {
    public static void main(String[] args) {
        byte b1 = 127;
        byte b2 = 128;
        System.out.println(b1 + b2);
    }
}
```

- 위의 코드의 실행 결과는 255가 아니라 에러이다. 에러 메시지의 내용은 다음과 같다.

```bash
java: incompatible types: possible lossy conversion from int to byte
```

- 위의 에러는 자바에서 변수를 다른 타입으로 변환할 때 데이터의 손실이 발생할 수 있는 경우에 주로 발생한다.

- 에러 메시지를 구체적으로 해석해보면 호환되지 않는 타입으로 `int`에서 `byte`로 손실 변환이 이루어진다는 의미로 이해할 수 있다.

```java
package codefactory;

public class ex8 {
    public static void main(String[] args) {
        byte b1 = 10;
        byte b2 = 20;
        byte b3 = b1 + b2;
        System.out.println(b1 + b2);
    }
}
```

- 위의 코드는 정상적으로 돌아가지 않는 코드이다.

- **_Java에서는 byte, short와 같은 작은 정수형 타입 간의 산술 연산을 수행할 때 컴파일러가 자동으로 int로 변환한다._**

- 따라서 위의 연산 결과는 `byte` 타입이 아니라 `int`타입으로 처리가 되는데 이를 `byte`타입의 변수인 b3에 저장하려고 하니까 에러가 발생하는 것이다.

- 에러를 해결하려면 다운캐스팅을 사용해서 명시적 형변환을 해주면 문제없이 저장할 수 있게 된다.

```java
package codefactory;

public class ex8 {
    public static void main(String[] args) {
        byte b1 = 10;
        byte b2 = 20;
        byte b3 = (byte) (b1 + b2);
        System.out.println(b3);
    }
}
```

---

## 사칙 연산자

- 산술 연산자에는 사칙 연산자와 나머지 연산자가 있다.

  - 사칙 연산자에는 우리가 일상생활에서 자주 사용하는 익숙한 것들(+, -, /, *)이다.
 
  - 나머지 연산자(%)는 나눗셈의 과정에서 발생하는 몫과 나머지 중에서 나머지를 구하기 위해 사용되는 연산자다.
 
```java
package codefactory;

public class ex7 {
    public static void main(String[] args) {
        int a = 10;
        int b = 4;

        System.out.println(a + b);    // a와 b를 더하면 14
        System.out.println(a - b);    // a에서 b를 빼면 6
        System.out.println(a / b);    // a를 b로 나누면 몫은 2
        System.out.println(a * b);    // a와 b를 곱하면 40
        System.out.println(a % b);    // a를 b로 나눈 나머지는 2
    }
}
```

---

## 나머지 연산자

- 나머지 연산자(%)는 왼쪽의 피연산자를 오른쪽의 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자다.

- 나머지 연산자는 나누는 수가 무조건 양수일 필요가 없다. 음수도 가능하다.

- 양수를 쓰건 음수를 쓰건 어차피 부호는 무시되므로 결과는 음수의 절댓값으로 나눈 나머지와 결과가 같다.

---

## 대소비교 연산자

- 두 피연산자의 값의 크고 작음을 비교하는 연산자로 참이라면 true를 거짓이라면 false를 반환한다.

- 기본형 타입의 경우 실제 데이터(data)를 저장하기 때문에 대소비교 연산자를 통해 직관적으로 비교가 가능하지만 참조형 타입의 경우 참조 주소를 저장하기 때문에 대소비교 연산자를 사용할 수 없다.

- 대소비교 연산자에는 `>`로 좌변 값이 더 큰지 확인하고 `<`로 우변 값이 더 큰지 확인하고 `>=`로 좌변 값이 크거나 같은지 확인하고 `<=`로 우변 값이 크거나 같은지를 확인한다.

---

## 등가비교 연산자

- 두 피연산자의 값이 같은지 다른지를 비교하는 연산자다.

- 대소비교 연산자와 달리 등가비교 연산자는 기본형 타입과 참조형 타입 모두 사용할 수 있다.

- 등가비교 연산자에는 `==`로 두 값이 같은지를 확인하고 `!=`로 두 값이 다른지를 확인한다.

```java
package codefactory;

public class ex9 {
    public static void main(String[] args) {
        int v1 = 10;
        int v2 = 10;
        if (v1 == v2) {
            System.out.println("두 값은 같습니다.");
        } else{
            System.out.println("두 값은 다릅니다.");
        }

        String s1 = "Hello";
        String s2 = "Hello";
        if (s1.equals(s2)) {
            System.out.println("두 문자열은 같습니다.");
        } else {
            System.out.println("두 문자열은 다릅니다.");
        }
    }
}
```

- 등가비교 연산자를 사용할 때 주의할 점이 있는데 등가비교를 해야할 피연산자의 타입이 숫자인지 아닌지에 따라서 사용법이 달라지기 때문이다.

- 숫자를 비교하는 경우 `==`을 사용하면 되지만 숫자가 아닌 문자열을 비교하는 경우 `isequals()` 메서드를 사용해야 한다.

  - `isequals()` 메서드는 두 문자열이 같으면 true를 반환하고, 두 문자열이 다르면 false를 반환한다.  

---

## 논리 연산자

- 논리 연산자 `&&`는 AND에 해당하며 AND의 왼쪽과 오른쪽 모두가 참이어야 true를 반환하고 하나라도 거짓이라면 false를 반환한다.

- 논리 연산자 `||`는 OR에 해당하며 OR의 왼쪽과 오른쪽 중에서 하나라도 참이라면 true를 반환하고 둘 다 거짓이라면 false를 반환한다.

- 논리 연산자가 실제로 어떻게 사용이 되는지를 예시를 들어 이해해보자.

  - Ex1. x는 10보다 크고 20보다 작다. → 이 문장은 AND를 의미하기 때문에 10과 20 사이의 숫자들에 대해서만 true를 반환한다.
 
  - Ex2. i는 2의 배수 또는 3의 배수이다. → 이 문장은 OR를 의미하기 때문에 2의 배수도 되면서 3의 배수가 되면 true를 반환한다.
 
  - Ex3. i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다. →  2의 배수여도 되고 3의 배수여도 되지만 6의 배수가 되지 않아야 true를 반환한다.
 
    - 예를 들어 6은 2의 배수라는 조건을 만족하고 3의 배수라는 조건도 만족하지만 6의 배수이기 때문에 위의 조건에 맞지 않아 false가 된다는 것이다.
   
    - 이를 논리 연산자를 사용한 식으로 표현을 하면 `(i % 2 == 0 || i % 3 == 0) && i % 6 != 0`으로 작성할 수 있다.

  - Ex4. 문자 ch는 숫자이다. → 아스키 코드에 대한 개념을 잘 알고 있다면 쉽게 해결할 수 있다.

    - 아스키 코드 표에서 문자 0은 10진수로 표현하면 48이 되고 문자 9는 10진수로 표현하면 57이 된다.

```java
package codefactory;

public class ex10 {
    public static void main(String[] args) {
        String str1 = "0123456789";
        String str2 = "not a number";
        boolean isNumber1 = true;
        boolean isNumber2 = true;

        for (char c : str1.toCharArray()) {
            if (48 <= c && c <= 57) {
                continue;
            } else {
                isNumber1 = false;
                break;
            }
        }

        for (char c : str2.toCharArray()) {
            if (48 <= c && c <= 57) {
                continue;
            } else {
                isNumber2 = false;
                break;
            }
        }

        if (isNumber1) {
            System.out.println("문자열이 숫자로 이루어져 있습니다.");
        } else {
            System.out.println("문자열이 숫자로만 이루어진 것은 아닙니다.");
        }

        if (isNumber2) {
            System.out.println("문자열이 숫자로 이루어져 있습니다.");
        } else {
            System.out.println("문자열이 숫자로만 이루어진 것은 아닙니다.");
        }
    }
}
```

- 논리 부정 연산자인 `!`은 결과를 반전시킨다. 다시 말해 참이라면 거짓으로 반전, 거짓이라면 참으로 반전시킨다.

![images_dingdoooo_post_21a96da2-139c-434f-bfe5-fd1fcf6ee62d_image](https://github.com/dnwls16071/TIL/assets/106802375/259bdb9a-df21-49a6-be5c-e884145cf418)

---

## 비트 연산자

- 비트 연산자는 피연산자를 비트 단위로 논리 연산한다. 이 때, 피연산자에 들어오는 수에는 실수가 들어올 수 없고 정수만 들어올 수 있다.

- 피연산자를 이진수로 표현했을 때 나오는 0과 1 그리고 연산자에 따라서 연산이 달라진다.

  - | (OR 연산자) : 피연산자 중 한 쪽의 값이 1이면 1을 결과로 얻고 둘 다 1이 아니라면 0을 결과로 얻는다.
 
  - & (AND 연산자) : 피연산자 양쪽의 값이 모두 1이면 1을 결과로 얻고 하나라도 0이면 0을 결과로 얻는다.
 
  - ^ (XOR 연산자) : 피연산자의 값이 서로 다를 때에만 1을 결과로 얻는다. 둘 다 1이거나 0이면 0을 결과로 얻는다.
 
- 비트 전환 연산자 `~`는 논리 부정 연산자의 개념과 비슷하다. 0을 1로 바꾸고, 1을 0으로 바꾼다.

- 시프트 연산자 `>>`, `<<`는 피연산자를 2진수로 표현했을 때 자릿수를 이동하는 것을 말한다.

  - 예를 들어 8을 2진수로 표현하면 `1000(2)`이 되는데 오른쪽 시프트 연산자를 사용하여 `8 >> 1`이라고 가정해보자.
 
  - 그렇게 되면 자릿수가 하나씩 오른쪽으로 이동하기 때문에 `100(2)`가 되어 이를 10진수로 변환하면 4가 나오게 된다.
 
  - 이번엔 왼쪽 시프트 연산자를 사용하여 `8 << 1`이라고 가정해보자.
 
  - 그렇게 되면 자릿수가 하나씩 왼쪽으로 이동하기 때문에 `10000(2)`가 되어 이를 10진수로 변환하면 16이 나오게 된다.
 
  - 결과를 보면 오른쪽 시프트 연산자를 사용하게 되면 현재 값의 1/2배가 되는 것이고 왼쪽 시프트 연산자를 사용하게 되면 현재 값의 2배가 되는 것을 알 수 있다.

---

## 조건 연산자

- 조건 연산자는 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항 연산자이며 삼항 연산자는 조건 연산자 하나뿐이다.

```bash
조건식 ? 반환값1 : 반환값2
```

- 물음표 앞의 조건식에 따라 결과값이 참(true)이면 반환값1을 반환하고 결과값이 거짓(false)이면 반환값2를 반환한다.

- if문을 사용하면 되지만 삼항 연산자를 사용하면 긴 코드를 단 한 줄로 축약할 수 있다는 장점이 있다.

- 조건 연산자를 중첩해서 사용하면 다음과 같이 사용할 수 있다.

```bash
result = x > 0 ? 1 : (x == 0 ? 0 : -1);
```

- 위의 코드를 해석하면 아래와 같이 나눠 해석을 할 수 있다.

  - ①-①. 만약 x의 값이 0보다 크다면?
 
    - ②-①. 1을 반환   
 
  - ①-②. 만약 x의 값이 0보다 작거나 같다면?
 
    - ②-①. 만약 x의 값이 0이라면?
   
      - ③-①. 0을 반환

    - ②-②. 만약 x의 값이 0이 아니라면?
   
      - ③-①. -1을 반환
     
---

## 대입 연산자

- 대입 연산자는 변수와 같은 저장 공간에 값 또는 수식의 연산 결과를 저장하는데 사용된다.

- 이 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 저장한다.

- 대입 연산자는 다른 연산자와 결합하여 복합 대입 연산자로 사용될 수 있다. 복합 대입 연산자의 대표적인 예시로 `+=`, `-=`, `/=`, `*=`가 있다.
