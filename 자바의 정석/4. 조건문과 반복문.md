## 목차

- 조건문 - if, switch
   - [if문](#if문)
   - [if-else문](#if-else문)  
   - [if-else if문](#if-else-if문)  
   - [중첩 if문](#중첩-if문)
   - [switch문](#switch문)
- 반복문 - for, while, do-while
   - [for문](#for문)  
   - [while문](#while문)  
   - [do-while문](#do-while문)  
   - [break문](#break문)  
   - [continue문](#continue문)
 
---

## if문

- if문은 가장 기본적인 조건문이며 조건식과 중괄호로 이루어져 있다.

- 만일(if) 조건식이 참(true)이면 중괄호 내부 블록의 문장들을 수행하라는 의미로 이해하면 된다.

```java
if (조건식) {
  // 조건식이 참(true)일 때 수행될 문장들을 적는다.
}
```

---

## if-else문

- if문의 변형인 if-else문의 구조는 다음과 같다. else블럭은 "그 밖의 다른"이라는 의미로 조건식의 결과가 참이 아닐 때 수행하라는 의미로 이해하면 된다.

- 상황에 따라 if문을 독립적으로 두 번 따로 작성해야하는 경우도 있지만 if-else문으로 한 번에 묶어서 작성해야하는 경우가 있으니 이는 요구 사항을 잘 이해하고 작성하면 된다.

```java
package codefactory;

import java.util.Scanner;

public class ex12 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int num = scanner.nextInt();

        if (num == 0) {
            System.out.println("입력한 숫자는 0이 맞습니다.");
        } else {
            System.out.println("입력한 숫자는 0이 아닙니다.");
        }
    }
}
```

---

## if-else if문

- if-else문은 두 가지 경우 중 하나가 수행되는 구조인데 처리해야할 경우의 수가 셋 이상인 경우에는 if-else if문을 사용하면 된다.

```java
package codefactory;

import java.util.Scanner;

public class ex13 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int score = scanner.nextInt();

        if (score >= 90) {
            System.out.println("A");
        } else if (score >= 80) {
            System.out.println("B");
        } else if (score >= 70) {
            System.out.println("C");
        } else if (score >= 60) {
            System.out.println("D");
        } else {
            System.out.println("F");
        }
    }
}
```

---

## 중첩 if문

- if문의 블럭 내부에 또 다른 if문을 포함시키는 것이 가능한데 이것을 중첩 if문이라고 한다.

- 중첩 횟수에는 제한이 없지만 중첩된 조건 판단 시에 사전 이해도가 낮은 상태에서 코드를 보게 되면 이해하기 어렵다.

- 또한 중첩 if문이 늘어나면 코드의 유지보수가 어려워지고 가독성이 낮아진다.

```java
package codefactory;

import java.util.Scanner;

public class ex14 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int score = scanner.nextInt();

        if (score >= 90) {
            if (score <= 94) {
                System.out.println("A0");
            } else {
                System.out.println("A+");
            }
        } else if (score >= 80) {
            if (score <= 84) {
                System.out.println("B0");
            } else {
                System.out.println("B+");
            }
        }
    }
}
```

## switch문

- if문은 조건식의 결과가 참과 거짓, 두 가지 밖에 없기 때문에 경우의 수가 많아질수록 else-if문을 계속 추가해야하므로 조건식이 많아져서 복잡해지고, 여러 개의 조건식을 계산해야하므로 처리시간도 많이 걸린다.

- 이러한 if문과 달리 switch문은 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고 표현 역시 간결하다.

- 다만 switch문은 제약 조건이 있다.

  - switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
 
  - case문의 값으로는 정수 상수만 가능하며 중복되지 않아야 한다.
 
    - case문의 값으로 조건을 판별하는 조건식이 들어갈 수 없다.

```java
package codefactory;

import java.util.Scanner;

public class ex15 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String grade = scanner.next();

        switch (grade) {
            case "A":
                System.out.println("A");
                break;
            case "B":
                System.out.println("B");
                break;
            case "C":
                System.out.println("C");
                break;
            case "D":
                System.out.println("D");
                break;
            default:
                System.out.println("E");
        }
    }
}
```

- switch문 역시 if문과 같이 중첩이 가능하다.

- 주민등록번호를 보면 `981024-2345678`과 같이 하이픈 뒤에 바로 나오는 숫자에 따라서 성별과 출생연도를 짐작할 수 있다.

  - 숫자가 1인 경우 : 2000년도 이전에 출생한 남자

  - 숫자가 2인 경우 : 2000년도 이후에 출생한 여자
 
  - 숫자가 3인 경우 : 2000년도 이후에 출생한 남자
 
  - 숫자가 4인 경우 : 2000년도 이후에 출생한 여자 

- 앞의 출생연도까지 고려를 해야겠지만 지금은 switch문의 중첩에 초점을 맞춰서 쓴 것이므로 이 부분에 대해서 이해하는 것으로 넘어가자.

```java
package codefactory;

import java.util.Scanner;

public class ex16 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        String regNo = scanner.nextLine();
        char info = regNo.charAt(7);

        switch (info) {
            case '1': case '3':
                switch (info) {
                    case '1':
                        System.out.println("2000년대 이전에 출생한 남자다.");
                        break;
                    case '3':
                        System.out.println("2000년대 이후에 출생한 남자다.");
                        break;
                }
            case '2': case '4':
                switch (info) {
                    case '2':
                        System.out.println("2000년대 이전에 출생한 여자다.");
                        break;
                    case '4':
                        System.out.println("2000년대 이후에 출생한 여자다.");
                        break;
                }
        }
    }
}
```

---

## for문

- for문은 반복 횟수를 알고 있을 때 적합하다. 구조가 조금 복잡하지만 직관적이라 이해하기 쉽다.

```java
for (초기화;조건식;증감식) {
  // 조건식이 참일 때 수행될 문장들을 적는다.
}
```

- for문으로도 while문과 같이 무한반복을 할 수 있다.

```java
for (;;) {
  // ...
}
```

- 조건이 생략된 경우 참(true)으로 간주되어 무한 반복문이 된다.

```java
package codefactory;

public class ex17 {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            System.out.println("i = " + i);
        }
    }
}
```

```java
package codefactory;

public class ex18 {
    public static void main(String[] args) {
        int i = 0;
        for (;;) {
            if (i == 10) {
                break;
            } else {
                System.out.println("i = " + i);
                i++;
            }
        }
    }
}
```

- 순차적으로 출력하는 것도 가능하지만 증감식이 어떻게 작성되었는지에 따라 다양하게 나타날 수 있다.

```java
package codefactory;

public class ex19 {
    public static void main(String[] args) {
        for (int i = 1; i < 100; i += 3) {
            System.out.println("i = " + i);
        }
    }
}
```

- if문 안에 또 다른 if문을 넣을 수 있는 것처럼 for문 안에 또 다른 for문을 포함시키는 것 역시 가능하다. 또한 중첩의 횟수는 제한이 없다.

- 중첩 for문을 이용해서 작성할 수 있는 대표적인 프로그램으로 구구단과 별 찍기가 있다. 한 번 작성해보자.

```java
// 별 찍기
package codefactory;

public class ex20 {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            for (int j = 0; j < i; j++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}
```

```bash
*
**
***
****
*****
```

```java
// 구구단(2단부터 9단까지)
package codefactory;

public class ex21 {
    public static void main(String[] args) {
        for (int i = 2; i <= 9; i++) {
            for (int j = 1; j <= 9; j++) {
                System.out.println(i + " x " + j + " = " + i * j);
            }
            System.out.println();
        }
    }
}
```

```bash
2 x 1 = 2
2 x 2 = 4
2 x 3 = 6
2 x 4 = 8
2 x 5 = 10
2 x 6 = 12
2 x 7 = 14
2 x 8 = 16
2 x 9 = 18

3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
3 x 4 = 12
3 x 5 = 15
3 x 6 = 18
3 x 7 = 21
3 x 8 = 24
3 x 9 = 27

...
```

- 향상된 for문(Enhanced for statement)?

  - JDK1.5부터 배열과 컬렉션에 저장된 요소에 접근할 때 기존보다 편리한 방법으로 처리할 수 있도록 for문의 새로운 문법이 추가되었다.

  - 타입은 배열 또는 컬렉션의 요소의 타입이어야 한다. 배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다.

  - 일반적인 for문과의 차이점을 꼽자면 for문의 경우 인덱스까지 취할 수 있고 향상된 for문은 배열이나 컬렉션에 저장된 요소들만 읽어올 수 있다.

  - 번호와 같은 요소를 필요로 한다면 향상된 for문보다는 일반적인 for문을 사용하는 것이 적합하다.

```java
for (타입 변수명 : 배열 또는 컬렉션) {
  // 반복할 문장
}
```

--- 

## while문

- for문에 비해 while문은 구조가 간단하다. 조건식의 결과가 거짓일 될 때까지 중괄호 블럭 내의 문장을 반복한다.

- for문으로 작성한 코드와 while문으로 작성한 코드를 비교해보자.

```java
package codefactory;

public class ex22 {
    public static void main(String[] args) {
        int i = 0;
        while (true) {
            if (i == 10) {
                break;
            } else {
                System.out.println("i = " + i);
                i++;
            }
        }
    }
}
```

```java
package codefactory;

public class ex23 {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            System.out.println("i = " + i);
        }
    }
}
```

- 스코프의 관점에서 보았을 때 ex22의 코드에서의 변수 i는 main 전체에서 유효한 것을 알 수 있고 ex23의 코드에서의 변수 i는 for문 블럭 내부에서만 유효한 것을 알 수 있다.

- 각 자릿수의 합을 구하는 코드를 for문을 이용한 방법과 while문을 이용한 방법으로 둘 다 작성해보고 코드를 비교해보자.

```java
package codefactory;

import java.util.Scanner;

public class ex24 {
    public static void main(String[] args) {
        int sum = 0;
        int num = 0;

        Scanner scanner = new Scanner(System.in);
        String tmp = scanner.nextLine();
        num = Integer.parseInt(tmp);

        while (num != 0) {
            sum += num % 10;
            num /= 10;
        }
        System.out.println("sum = " + sum);
    }
}
```

```java
package codefactory;

import java.util.Scanner;

public class ex25 {
    public static void main(String[] args) {
        int sum = 0;
        int num = 0;

        Scanner scanner = new Scanner(System.in);
        String tmp = scanner.nextLine();
        num = Integer.parseInt(tmp);

        while (num != 0) {
            sum += num % 10;
            num /= 10;
        }
        System.out.println("sum = " + sum);
    }
}
```

```bash
2222222222
Exception in thread "main" java.lang.NumberFormatException: For input string: "2222222222"
	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)
	at java.base/java.lang.Integer.parseInt(Integer.java:661)
	at java.base/java.lang.Integer.parseInt(Integer.java:777)
	at codefactory.ex25.main(ex25.java:12)
```

- 문자열을 숫자로 표현하는 과정에서 위와 같은 에러를 마주했다.

- `Integer.parseInt()`의 경우 문자열을 정수형으로 타입을 바꿔준다. 이 때, 정수형의 타입은 `int`으로 약 ±20억까지의 범위에 해당하는 문자를 숫자로 바꿔주는 것이라고 이해하면 된다.

- `int`타입의 변수에는 값을 저장할 수 없으므로 `BigInteger`클래스를 사용하면 된다.

```java
package codefactory;

import java.math.BigInteger;
import java.util.Scanner;

public class ex25 {
    public static void main(String[] args) {
        BigInteger sum = BigInteger.ZERO;

        Scanner scanner = new Scanner(System.in);
        String tmp = scanner.nextLine();
        BigInteger num = new BigInteger(tmp);

        while (!num.equals(BigInteger.ZERO)) {
            sum = sum.add(num.remainder(BigInteger.TEN));
            System.out.println(sum);
            num = num.divide(BigInteger.TEN);
            System.out.println(num);
        }
        System.out.println("sum = " + sum);
    }
}
```

- `BigInteger`는 클래스로 기본형 타입이 아닌 참조형 타입으로 객체의 주소를 저장하는 형식이기 때문에 복합 대입 연산자(Ex. +=)를 사용할 수 없다.

- 변수 sum은 10으로 나눈 나머지 값을 누적해서 더한 결과를 저장하는 변수고 변수 num은 10으로 나눈 나머지를 할당하는 변수다.

- 변수 sum에 add메서드로 누적 합을 구할 수 있다.

---

## do-while문

- do-while문은 while문의 변형으로 기본적인 구조는 while문과 같으나 조건식과 중괄호 블록의 순서를 바꿔놓은 것이다.

- while문은 조건식의 결과가 참이냐 거짓이냐에 따라 중괄호 블럭 내부의 문장이 한 번도 실행되지 않을 수 있지만 do-while문은 최소한 한 번은 수행될 것을 보장한다.

```java
do {
  // 조건식의 연산 결과가 참일 때 수행될 문장들을 적는다.
} while (조건식)
```

---

## break문

- 앞선 switch문에서 break문을 작성했던 경험이 있을 것이다. 반복문에서도 break문을 사용할 수 있는데 switch문에서 그랬던 것처럼 break문은 자신이 포함된 인접한 반복문을 벗어난다.

- 주로 if문과 함께 사용되어 특정 조건을 만족하면 반복문을 벗어나도록 한다.

```java
package codefactory;

public class ex26 {
    public static void main(String[] args) {
        int sum = 0;
        int i = 0;

        while (true) {
            if (sum > 100) {
                break;
            } else {
                ++i;
                sum += i;
                System.out.println("i = " + i + " sum = " + sum);
            }
        }
    }
}
```

- 변수 sum의 값이 100을 넘는 순간 break문이 수행되어 자신이 속한 반복문을 그 즉시 벗어난다.

- for문과 while문을 활용한 무한 반복문에서 break문은 필수로 작성을 해주어야 한다.

---

## continue문

- continue문은 반복문 내에서만 사용될 수 있으며, 반복이 진행되는 도중에 continue문을 만나면 반복문의 끝으로 이동하여 다음 반복으로 넘어간다.

- continue문은 반복문 전체를 벗어나지 않고 다음 반복을 계속 수행한다는 점이 break문과 다르다.

```java
package codefactory;

public class ex27 {
    public static void main(String[] args) {
        for (int i = 0; i <= 10; i++) {
            if (i % 3 == 0) {
                continue;
            } else {
                System.out.println("i = " + i);
            }
        }
    }
}
```

- 위의 코드에서 3의 배수의 경우 continue를 통해 제외하고 다음 반복을 계속 수행하도록 작성했다.

- continue문은 전체 반복 중에 특정조건을 만족하는 경우를 제외하고자 할 때 유용하게 사용할 수 있다.
