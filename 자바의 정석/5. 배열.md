## 목차

- 배열
   - [배열(array)이란?](#배열(array)이란?)
   - [배열의 선언과 생성](#배열의-선언과-생성)  
   - [배열의 길이와 인덱스](#배열의-길이와-인덱스)  
   - [배열의 초기화](#배열의-초기화)
   - [배열의 복사](#배열의-복사)
   - [배열의 활용](#배열의-활용)
- String 배열
   - [String배열의 선언과 생성](#String배열의-선언과-생성)  
   - [String배열의 초기화](#String배열의-초기화)  
   - [char배열과 String클래스](#char배열과-String클래스)  
   - [커맨드 라인을 통해 입력받기](#커맨드-라인을-통해-입력받기)
- 다차원 배열
   - [2차원 배열의 선언과 인덱스](#2차원-배열의-선언과-인덱스)  
   - [2차원 배열의 초기화](#2차원-배열의-초기화)  
   - [가변 배열](#가변-배열)  
   - [다차원 배열의 활용](#다차원-배열의-활용)

---

## 배열(array)이란?

- 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 배열(array)이라고 한다.

- 많은 양의 데이터를 저장하기 위해서 그 데이터의 숫자만큼 변수를 선언해야 한다면 매우 힘들어지는데 이를 해결하기 위해 배열이라는 개념이 도입되었다.

- 배열을 선언하고 생성하면 메모리 어딘가에 배열을 나타내는 참조 변수가 만들어지고 이 참조 변수에 배열 자체가 저장되는 것이 아니라 배열을 다루는 주소값이 저장된다.

---

## 배열의 선언과 생성

- 배열을 선언하는 방법은 간단하다. 원하는 타입의 변수를 선언하고 변수 또는 타입에 배열임을 의미하는 대괄호를 붙이면 된다.

```java
package codefactory;

public class ex28 {
    public static void main(String[] args) {
        int[] score = new int[5];

        System.out.println(score);
    }
}
```

- 위의 코드를 실행하면 참조 변수의 주소를 알 수 있게 된다. 배열의 선언과 생성 과정을 단계별로 확인해보자.

1. `int[] score;`

- int형 배열 참조변수 score를 선언한다. 데이터를 저장할 수 있는 공간은 아직 마련된 것이 아니다.

2. `score = new int[5];`

- 연산자 new에 의해 메모리의 빈 공간에 5개의 int형 데이터를 저장할 수 있는 공간이 마련된다.

- 그리고 각 배열 요소는 자동적으로 int의 default인 0으로 초기화된다.

- 끝으로 대입 연산자(=)에 의해서 만들어진 배열을 가리키는 참조 주소가 score에 저장된다.

- 이제 참조변수 score를 통해서 생성된 배열에 값을 저장하거나 읽어 올 수 있다. 이 배열은 길이가 5인 int형 타입의 배열이며, 참조변수의 이름을 따서 score 배열이라고 부르면 된다.

---

## 배열의 길이와 인덱스

- 생성된 배열의 각 저장 공간을 배열의 요소(element)라고 하며, 배열이름[인덱스]의 형식으로 배열의 요소에 접근한다.

- 인덱스(index)는 배열의 요소마다 붙여진 일련번호로 각 요소를 구별하는데 사용된다. 이 때, 인덱스는 1이 아닌 0부터 시작한다.

```java
package codefactory;

public class ex28 {
    public static void main(String[] args) {
        int[] score1 = new int[5];

        score1[0] = 0;
        score1[1] = 1;
        score1[2] = 2;
        score1[3] = 3;
        score1[4] = 4;
        System.out.println(score1);
        System.out.println(score1[0]);
        System.out.println(score1[1]);
        System.out.println(score1[2]);
        System.out.println(score1[3]);
        System.out.println(score1[4]);
    }
}
```

- 위의 코드에선 중복을 처리하지 않아 모든 요소를 하나하나 출력하고 있다. 배열의 길이가 작은 경우에는 크게 문제가 되지 않지만 배열의 길이가 큰 경우에는 일일이 하나하나 치는 것은 사실상 불가능한 일이다.

- 중복을 제거하기 위해서 for문 반복문을 이용해 모든 요소를 출력하도록 코드를 리팩토링 할 수 있다.

```java
package codefactory;

public class ex29 {
    public static void main(String[] args) {
        int[] score1 = new int[5];

        score1[0] = 0;
        score1[1] = 1;
        score1[2] = 2;
        score1[3] = 3;
        score1[4] = 4;

        // Enhanced for statement
        for (int i : score1) {
            System.out.println(i);
        }

        for (int i = 0; i < score1.length; i++) {
            System.out.println("Index " + i + ": " + score1[i]);
        }
    }
}
```

- 자바에서는 JVM이 모든 배열의 길이를 별도로 관리하며, 배열이름.length를 통해서 배열의 길이에 대한 정보를 얻을 수 있다.

- 이 때, 배열은 한 번 생성하면 길이를 변경할 수 없기 때문에 이미 생성된 배열의 길이는 변하지 않는다.

```java
int[] arr = new int[10];
// arr.length = 20;  → 배열의 길이는 변경할 수 없다.
```

- 배열은 한 번 선언되고 나면 길이를 변경할 수 없다고 배웠는데, 그렇다면 배열에 저장할 공간이 부족한 경우에는 어떻게 해결할까?

- 이 때는 더 큰 길이의 새로운 배열을 생성한 다음 기존의 배열에 저장된 값들을 그대로 새로운 배열에 복사하면 된다.

- 하지만 이 작업은 꽤나 비용이 많이 들기 때문에 처음부터 배열의 길이를 넉넉하게 잡아줘서 새로 배열을 생성해야하는 상황이 가능한 적게 발생하도록 해야 한다.

- 그렇다고 배열의 길이를 너무 크게 잡으면 메모리를 낭비하게 되므로 기존의 2배 정도의 길이로 생성하는 것이 좋다.

---

## 배열의 초기화

- 배열의 생성과 동시에 자동적으로 자신의 타입에 해당하는 기본값으로 초기화되므로 배열을 사용하기 전에 따로 초기화를 해주지 않아도 되지만, 원하는 값을 저장하려면 각 요소마다 값을 지정해 줘야한다.

```java
package codefactory;

public class ex30 {
    public static void main(String[] args) {
        int[] arr = new int[5];

        // int형 타입의 배열의 각 요소의 기본값은 0
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }

        // for문으로 배열 초기화
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
            System.out.println(arr[i]);
        }
    }
}
```

```java
package codefactory;

public class ex30 {
    public static void main(String[] args) {
        int[] arr = new int[5];

        // int형 타입의 배열의 각 요소의 기본값은 0
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }

        // for문으로 배열 초기화
        for (int i = 0; i < arr.length; i++) {
            arr[i] = i;
            System.out.println(arr[i]);
        }

        // new int[] 뒤에 중괄호를 붙여 배열 초기화
        int[] arr2 = new int[]{10, 20, 30, 40, 50};

        // 배열의 선언과 초기화를 따로따로
        int[] arr3;
        arr3 = new int[]{10, 20, 30, 40, 50};

        // new int[] 생략 가능
        int[] arr4 = {10, 20, 30, 40, 50};

        // Enhanced for statement
        for (int i : arr2) {
            System.out.println(i);
        };

        // Enhanced for statement
        for (int i : arr3) {
            System.out.println(i);
        };

        // Enhanced for statement
        for (int i : arr4) {
            System.out.println(i);
        };
    }
}
```

- 배열의 모든 요소를 출력할 때에 위와 같이 for문을 무조건 써야만 하는 것은 아니다. `Arrays.toString(배열이름)`을 사용하면 Python에서의 출력과 같이 사용할 수 있게 된다.

```java
package codefactory;

import java.util.Arrays;

public class ex31 {
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5};

        System.out.println(Arrays.toString(array));
    }
}
```

---

## 배열의 복사

- 배열은 한 번 생성하면 이후에 그 길이를 변경할 수 없기 때문에 더 많은 저장 공간이 필요하다면 보다 큰 배열을 새로 만들고 기존 배열의 원소를 새로운 배열로 복사해야한다.

- 배열을 복사하는 방법은 for문을 이용해서 배열을 복사하는 방법과 `System.arraycopy()`를 이용해서 배열을 복사하는 두 가지 방법이 존재한다.

```java
package codefactory;

import java.util.Arrays;

public class ex32 {
    public static void main(String[] args) {
        int[] ord_arr = new int[5];
        for (int i = 0; i < ord_arr.length; i++) {
            ord_arr[i] = i;
        }

        System.out.println(Arrays.toString(ord_arr));

        int[] new_arr = new int[ord_arr.length * 2];
        for (int i = 0; i < ord_arr.length; i++) {
            new_arr[i] = ord_arr[i];
        }

        // 참조변수 ord_arr이 새로 만든 배열을 가리키도록 한다
        ord_arr = new_arr;
        System.out.println(Arrays.toString(ord_arr));
    }
}
```

- 배열은 참조변수를 통해서만 접근할 수 있기 때문에 자신을 가리키는 참조변수가 없는 배열은 사용할 수 없다.

- 이렇게 쓸모없게 된 배열은 JVM의 가비지 컬렉터에 의해서 자동적으로 메모리에서 제거된다.

- 위와 같이 for문을 이용하는 방법도 있지만 for문 대신에 System 클래스의 arraycopy()를 사용하면 보다 간단하고 빠르게 배열을 복사할 수 있다.

- for문은 배열의 요소 하나하나에 접근해서 복사하지만, arraycopy()는 지정된 범위의 값들을 한 번에 통째로 복사된다. 각 요소들이 연속적으로 저장되어 있다는 배열의 특성때문에 이렇게 처리하는 것이 가능한 것이다.

```java
package codefactory;

import java.util.Arrays;

public class ex33 {
    public static void main(String[] args) {
        int[] ord_arr = {1, 2, 3, 4, 5};

        int[] new_arr = new int[10];
        System.out.println(Arrays.toString(new_arr)); // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

        System.arraycopy(ord_arr, 0, new_arr, 0, ord_arr.length);
        System.out.println(Arrays.toString(new_arr)); // [1, 2, 3, 4, 5, 0, 0, 0, 0, 0]
    }
}
```

```bash
System.arraycopy(ord_arr, 0, new_arr, 0, ord_arr.length);
```

- ord_arr[0]에서 new_arr[0]으로 ord_arr.length만큼 데이터를 복사하라는 의미이다.

- 이 때, 복사하려는 배열의 위치가 적절하지 못하여 복사하려는 내용보다 여유 공간이 적은 경우 `ArrayIndexOutOfBoundsException` 에러가 발생한다.

--- 

## 배열의 활용

1. 배열의 모든 요소를 더해서 총합과 평균을 구하는 코드

```java
package codefactory;

public class ex34 {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int sum = 0;
        double avg;

        for (int i : arr) {
            sum += i;
        }

        avg = (double) sum / arr.length;
        System.out.println("총합 sum = " + sum);
        System.out.println("평균 avg = " + avg);
    }
}
```

2. 배열의 요소 중에서 제일 큰 값과 제일 작은 값을 구하는 코드

```java
package codefactory;

public class ex35 {
    public static void main(String[] args) {
        // 정렬이 되지 않은 무작위 배열
        int[] arr = {10, 3, 6, 2, 1, 5, 4, 8, 9, 7};
        int maxNum = arr[0];
        int minNum = arr[0];
        
        for (int i = 1; i < arr.length; i++) {
            if (minNum < arr[i]) {
                minNum = arr[i];
            }

            if (maxNum > arr[i]) {
                maxNum = arr[i];
            }
        }

        System.out.println("최댓값 : " + maxNum);
        System.out.println("최솟값 : " + minNum);
    }
}
```

3. 배열의 요소의 순서를 반복해서 바꾸는 코드(카드 섞기, 로또번호 생성)

```java
package codefactory;

import java.util.Arrays;

public class ex36 {
    public static void main(String[] args) {
        int[] numArr = new int[10];

        for (int i = 0; i < numArr.length; i++) {
            numArr[i] = i;
        }

        System.out.println(Arrays.toString(numArr));

        for (int i = 0; i < numArr.length; i++) {
            // 0~9중 임의의 값을 얻는다.
            int n = (int) (Math.random() * 10);
            // 배열의 첫 번째 요소와 임의의 값에 해당하는 요소를 교체한다.
            int tmp = numArr[0];
            numArr[0] = numArr[n];
            numArr[n] = tmp;
        }

        System.out.println(Arrays.toString(numArr));
    }
}
```

```java
package codefactory;

import java.util.Arrays;

public class ex37 {
    public static void main(String[] args) {
        int[] lotto = new int[6];
        boolean[] isUsed = new boolean[46];

        for (int i = 0; i < lotto.length; i++) {
            while (true) {
                int tmp = (int) ((Math.random() * 45) + 1);
                if (!isUsed[tmp]) {
                    lotto[i] = tmp;
                    isUsed[tmp] = true;
                    break;
                }
            }
        }
        System.out.println(Arrays.toString(lotto));
    }
}
```

- 로또 번호를 저장할 크기 6의 배열과 중복 검증을 위해 숫자 사용 여부를 저장할 크기 45의 배열을 선언 후 생성한다.

- 변수 tmp를 만들어 임시 변수를 만들되 만약 해당 숫자가 사용된 적이 있다면 무한 반복을 돌리고 만약 해당 숫자가 사용된 적이 없다면 사용한 것으로 처리하고 로또 번호를 갱신한다.

4. 임의의 값으로 배열을 채우는 코드

```java
package codefactory;

import java.util.Arrays;

public class ex38 {
    public static void main(String[] args) {
        int[] arr = new int[5];

        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int) (Math.random() * 10);
        }

        System.out.println(Arrays.toString(arr));
    }
}
```

5. 정렬하기(sort) - 오름차순/내림차순으로 배열을 정렬하는 코드

```java
package codefactory;

import java.util.Arrays;

public class ex39 {
    public static void main(String[] args) {
        // 배열의 길이를 10으로 설정
        int[] numArr = new int[10];

        // 배열의 원소를 임의의 값으로 채우기
        for (int i = 0; i < numArr.length; i++) {
            numArr[i] = (int) (Math.random() * 10);
        }

        // 버블 정렬 알고리즘 구현 코드(최적화)
        for (int i = 0; i < numArr.length; i++) {
            boolean changed = false;
            for (int j = 0; j < numArr.length - 1 - i; j++) {
                if (numArr[j] > numArr[j + 1]) {
                    int tmp = numArr[j];
                    numArr[j] = numArr[j + 1];
                    numArr[j + 1] = tmp;
                    changed = true;
                }
            }

            if (!changed) {
                break;
            }
            System.out.println(Arrays.toString(numArr));
        }
    }
}
```

- 위와 같은 정렬 알고리즘을 버블 정렬 알고리즘이라고 하는데 마치 거품이 위로 올라가는 모습을 연상케 한다는 것에서 비롯된 것이다.

- 기본적으로 2중 for문을 사용하기때문에 시간 복잡도는 `O(N^2)`으로 이를 최적화하기 위해서 숫자의 위치가 바뀌었는지를 나타내는 boolean형 타입의 변수를 만들어 만약 교환되지 않았다면 즉, 정렬이 수행된 경우라면 그 즉시 멈추도록 할 수 있다.

6. 빈도수를 구하는 코드

```java
package codefactory;

import java.util.Arrays;

public class ex40 {
    public static void main(String[] args) {
        int[] array = new int[10];
        int[] count = new int[10];

        for (int i = 0; i < array.length; i++) {
            array[i] = (int) (Math.random() * 10);
            count[array[i]] += 1;
        }

        System.out.println(Arrays.toString(array));
        System.out.println(Arrays.toString(count));
    }
}
```

---

## String배열의 선언과 생성

- 배열의 타입이 String인 경우에도 int배열의 선언과 생성방법은 다르지 않다. 예를 들어 3개의 문자열(String)을 담을 수 있는 배열을 생성하는 문장은 다음과 같다.

```java
String[] name = new String[3];
```

- 참조 변수 name의 타입이 String으로 위와 같이 작성을 하게 되면 배열을 선언하고 생성하게 된다.

- 이 때, 참조형 변수의 기본값은 null이므로 각 요소의 값은 null로 초기화 된다.(int타입의 배열의 경우 기본값은 0)

- 참고로 변수의 타입에 따른 기본값은 다음과 같다.

| 자료형 | 기본값 |
|--------|--------|
| boolean | false |
| char | '\u0000' |
| byte, short, int | 0 |
| long | 0L |
| float | 0.0f |
| double | 0.0d 또는 0.0 |
| 참조형 변수 | null |

--- 

## String 배열의 초기화

- 초기화 역시 int배열과 동일한 방법으로 한다.

```java
package codefactory;

public class ex41 {
    public static void main(String[] args) {
        String[] arr = {"Jang", "Woo", "Jin"};
        for (int i = 0; i < arr.length; i++) {
            System.out.println("arr["+i+"] = " + arr[i]);
        }

        System.out.println();

        arr[0] = "Park";
        for (int i = 0; i < arr.length; i++) {
            System.out.println("arr["+i+"] = " + arr[i]);
        }
    }
}
```

---

## char배열과 String클래스

- 문자열을 저장할 때 String타입의 변수를 사용했다. 사실 문자열이라는 용어는 "문자를 연이어 늘어놓은 것"을 의미하므로 문자배열인 char배열과 같은 뜻이다.

- 그런데 Java에서는 char배열이 아닌 String클래스를 사용하여 문자열을 처리하는 이유는 String클래스가 char배열에 여러 가지 기능을 추가하여 확장한 것이기 때문이다.

- 그래서 char배열을 사용하는 것보다 String클래스를 사용하는 것이 문자열을 다루기 더 편리하므로 String클래스를 적극 활용하자.

```java

package codefactory;

import java.util.Arrays;

public class ex42 {
    public static void main(String[] args) {
        String str = "ABCDE";

        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            System.out.println("str.charAt("+i+"): " + ch);
        }

        char[] chrarr = str.toCharArray();
        System.out.println(Arrays.toString(chrarr));
    }
}
```

- String클래스의 주요 메서드

| 메서드 | 설명 |
|--------|--------|
| char charAt(int index) | 문자열에서 해당 위치(index)에 있는 문자를 반환한다. |
| int length | 문자열의 길이를 반환한다. |
| String substring(int from, int to) | 문자열에서 해당범위(from~to-1)에 있는 문자열을 반환한다. |
| boolean equals(Object obj) | 문자열의 내용이 obj와 같은지 확인한다. 같으면 결과는 true, 다르면 결과는 false를 반환한다. |
| char[] toCharArray() | 문자열을 문자배열(char[])로 변환해서 반환한다. |

---

## 커맨드 라인을 통해 입력받기

```java
package codefactory;

public class ex43 {
    public static void main(String[] args) {
        if (args.length != 3) {
            System.out.println("Usage: java ex43 <num1> <operator> <num2>");
        }

        int num1 = Integer.parseInt(args[0]);
        char op = args[1].charAt(0);
        int num2 = Integer.parseInt(args[2]);
        int result = 0;

        switch (op) {
            case '+':
                result = num1 + num2;
                break;
            case '-':
                result = num1 - num2;
                break;
            case '*':
                result = num1 * num2;
                break;
            case '/':
                result = num1 / num2;
                break;
            case '%':
                result = num1 % num2;
                break;
            default:
                System.out.println("식별할 수 없는 연산자입니다.");
        }
        System.out.println(result);
    }
}
```

- Scanner클래스의 nextLine()외에도 화면을 통해 사용자로부터 값을 입력받을 수 있는 방법이 존재하는데 바로 커맨드 라인을 이용하는 방법이다.

- 프로그램을 실행할 때, 클래스 이름 뒤에 공백 문자로 구분하여 여러 개의 문자열을 프로그램에 전달할 수 있다.

- 터미널에 `java 클래스명 문자열`을 입력하면 실행되는 것을 볼 수 있다.

---

## 2차원 배열의 선언과 인덱스

- 2차원 배열을 선언하는 방법은 1차원 배열과 같다. 다만 괄호[]가 하나 더 들어갈 뿐이다.

- 2차원 배열은 주로 테이블 형태의 데이터를 담는데 사용되며, 만일 4행 3열의 데이터를 담기 위한 배열을 생성하려면 다음과 같이 한다.

```java
int[][] score = new int[4][3];
```

---

## 2차원 배열의 초기화

- 예를 들어, 5명의 학생의 점수 테이블을 아래와 같이 2차원 배열로 만들어보자.

```java
package codefactory;

public class ex44 {
    public static void main(String[] args) {
        int[][] score = {
                {100, 100, 100},
                {20, 20, 20},
                {30, 30, 30},
                {40, 40, 40},
                {50, 50, 50},
        };
        int korTotal = 0, engTotal = 0, mathTotal = 0;
        for (int i = 0; i < score.length; i++) {
            int sum = 0;
            double avg;

            korTotal += score[i][0];
            engTotal += score[i][1];
            mathTotal += score[i][2];
            for (int j = 0; j < score[i].length; j++) {
                sum += score[i][j];
            }
            avg = (double) sum / score[i].length;
            System.out.println("sum = " + sum + ", avg = " + avg);
        }
    }
}
```

---

## 가변 배열

- 자바에서는 2차원 이상의 배열을 '배열의 배열'의 형태로 처리한다는 사실을 이용하면 보다 자유로운 형태의 배열을 구성할 수 있다.

```java
package codefactory;

public class ex45 {
    public static void main(String[] args) {
        int[][] score = {
                {100, 100, 100, 100},
                {20, 20, 20},
                {30, 30},
                {40},
                {50, 50, 50, 50, 50}
        };

        for (int i = 0; i < score.length; i++) {
            for (int j = 0; j < score[i].length; j++) {
                System.out.print(score[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

---

## 다차원 배열의 활용

1. 영어 단어를 보여주고 뜻을 맞추는 게임 코드

```java
package codefactory;

import java.util.Scanner;

public class ex46 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int count = 0;

        String[][] dictionary = {
                {"Chair", "의자"},
                {"Computer", "컴퓨터"},
                {"Integer", "정수"}
        };

        for (int i = 0; i < dictionary.length; i++) {
            String meaning = scanner.nextLine();
            if (dictionary[i][1].equals(meaning)) {
                System.out.println("정답입니다.");
                count += 1;
            } else {
                System.out.println("오답입니다.");
            }
        }

        System.out.println("맞춘 문제의 갯수 : " + count);
    }
}
```
