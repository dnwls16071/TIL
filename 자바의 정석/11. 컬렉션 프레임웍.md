## 목차

- 컬렉션 프레임웍(Collections Framework)
   - [컬렉션을 위한 자바 인터페이스와 클래스 구성도](#컬렉션을-위한-자바-인터페이스와-클래스-구성도)
   - [컬렉션의 특징](#컬렉션의-특징)
   - [제네릭](#제네릭)
   - [제네릭 타입 매개변수](#제네릭-타입-매개변수)
   - [ArrayList](#ArrayList)
   - [LinkedList](#LinkedList)
   - [Stack과 Queue](#Stack과-Queue)
   - [Iterator, ListIterator, Enumeration](#Iterator-ListIterator-Enumeration)
   - [Arrays](#Arrays)
   - [Comparator와 Comparable](#Comparator와-Comparable)
   - [HashSet](#HashSet)
   - [TreeSet](#TreeSet)
   - [HashMap과 Hashable](#HashMap과-Hashable)
   - [TreeMap](#TreeMap)
   - [Properties](#Properties)
   - [Collections](#Collections)
   - [컬렉션 클래스 정리 & 요약](#컬렉션-클래스-정리--요약)

---

## 컬렉션을 위한 자바 인터페이스와 클래스 구성도

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/b97d2483-c0c0-45c8-a7ab-b9657bbc7056)

- 컬렉션 프레임웍은 크게 Collections 인터페이스와 Map 인터페이스로 나뉜다.

- 그림에서 보이는 Vector, Stack, Hashtable, Properties와 같은 클래스들은 컬렉션 프레임웍이 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임웍의 명명법을 따르지 않는다.

- Vector이나 Hashtable과 같은 기존의 컬렉션 클래스들은 호환을 위해 설계를 변경해서 남겨두었지만 가능하면 사용하지 않는 것이 좋다.

- 대신에 새로 추가된 ArrayList와 HashMap을 사용하길 권장한다.

---

## 컬렉션의 특징

①. 컬렉션은 제네릭(generics)이라는 기법으로 구성되어 있다.

  - 컬렉션 클래스나 인터페이스의 이름에는 항상 <V>, <E>, <K>등이 항상 포함되는데 이를 타입 매개변수라고 한다.

②. 컬렉션의 요소는 객체만 가능하다.

  - int, char, double 등의 기본형 타입의 데이터는 컬렉션의 요소로 불가능하다.

---

## 제네릭

- 제네릭(generics)은 JDK 1.5 버전부터 도입되었다.

- 자바에서 제네릭은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 말한다.

- 변수를 사용할 때 데이터 타입을 정의한 뒤 사용하듯이 꺽쇠(`< >`)안에 데이터 타입을 지정해서 사용하면 된다.

---

## 제네릭 타입 매개변수

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/50336b30-7f6e-49a3-8344-beadcb35bb5e)

- 꺽쇠(`< >`)안에 데이터 타입을 지정해서 사용한다.

```java
// 제네릭 타입 매개변수에 정수 타입을 할당
FruitBox<Integer> intBox = new FruitBox<>(); 

// 제네릭 타입 매개변수에 실수 타입을 할당
FruitBox<Double> intBox = new FruitBox<>(); 

// 제네릭 타입 매개변수에 문자열 타입을 할당
FruitBox<String> intBox = new FruitBox<>(); 

// 클래스도 넣어줄 수 있다. (Apple 클래스가 있다고 가정)
FruitBox<Apple> intBox = new FruitBox<Apple>();
```

- 이를 그림으로 표현하면 제네릭 타입 전파가 이루어진다고 볼 수 있다. `<T>`부분에서 실행부에서 타입을 받아와 내부에서 `<T>`타입으로 지정한 멤버들에게 전파하여 타입이 구체적으로 설정되는 것이다.

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/7809eca8-0de9-4ba3-921a-c46c7bd399d1)

- 이를 전문 용어로 구체화(Specialization)라고 한다.

- JDK 1.7 버전 이후부터, new 생성자 부분의 제네릭 타입은 생략할 수 있게 되었다.

```java
// new 생성자 부분의 제네릭 타입 생략 가능
FruitBox<Apple> intBox = new FruitBox<>();
```

- 위의 컬렉션의 특징에서 제네릭은 내부에서 사용할 데이터 타입을 외부에서 지정해준다고 했는데 이 제네릭 타입 매개변수로 사용하는 문자가 별도로 정해져있다.

```bash
<E> : Element를 의미하며 컬렉션에서 요소를 의미할 때 사용

<T> : Type을 의미

<V> : Value를 의미

<K> : Key를 의미
```

---

## ArrayList

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/b3811dde-0037-488d-936a-72754a15a032)

- ArrayList는 컬렉션 프레임웍에서 가장 많이 사용되는 컬렉션 클래스 중의 하나로 List 인터페이스를 구현한 구현체 클래스이다.

- 배열을 이용하여 만든 리스트로 **데이터의 저장 순서가 유지되고 중복을 허용한다.**

- 데이터 양에 따라 공간을 유동적으로 변화시킬 수 있다.

- 생성할 때 지정한 크기보다 더 많은 객체를 저장하면 자동적으로 크기가 늘어나기는 하지만 이 과정에서 처리시간이 많이 소요된다.

- 삽입/삭제가 느리다.

```java
package collections;

import java.util.ArrayList;
import java.util.Collections;

public class ArrayListEx {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList(10);

        list.add(1);
        list.add(5);
        list.add(4);
        list.add(3);
        list.add(2);

        Collections.sort(list);
        System.out.println(list);
    }
}
```

[Java API 공식문서] : https://docs.oracle.com/javase/8/docs/api/

--- 

## LinkedList

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/c32912d8-9bb1-4a0c-a032-2167010077d4)

- 배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽어 오는데 걸리는 시간(접근시간, access time)이 가장 빠르다는 장점을 가진다.

- 하지만  배열은 크기를 변경할 수 없고 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 소요된다는 단점이 있다.
  
- 배열의 단점을 보완하기 위하여 링크드 리스트라는 자료구조가 고안되었다. 배열은 모든 데이터가 연속적으로 존재하지만 링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성되어 있다.

- 위의 그림에서 알 수 있듯이 하나의 노드에는 데이터와 다음 요소에 대한 참조값(주소값)이 들어있다.

- LinkedList 역시 List 인터페이스를 구현한 것이므로 아래와 같이 List타입의 참조변수로 LinkedList 타입의 인스턴스를 참조할 수 있는 것이다.

```java
package collections;

import java.util.LinkedList;
import java.util.List;

public class LinkedListEx {
    public static void main(String[] args) {
        List<Integer> ll = new LinkedList<>();

        ll.add(1);
        ll.add(2);
        ll.add(3);

        System.out.println(ll.get(0));
    }
}
```

---

## Stack과 Queue

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/36e1b4e2-ba7a-4cfe-8415-44f51c1ea018)

- Stack은 LIFO(Last-In-First-Out)의 자료구조로 연탄을 생각하면 이해하기 쉽다.

- 아궁이에 연탄을 하나씩 쌓게 되면 맨 아래에 있는 연탄을 빼려면 맨 위에 있는 연탄을 빼야한다.

- 따라서 마지막으로 넣은 것이 먼저 나가는 LIFO가 되는 것이다.

- 스택에 원소를 넣을 때는 push연산을, 스택에서 맨 위의 원소를 뺄 때는 pop연산을 한다.

- 스택의 경우 순차적으로 데이터를 추가하고 삭제하기 때문에 ArrayList와 같은 배열기반의 클래스로 구현하기에 적합하다.

```java
package collections;

import java.util.Stack;

public class StackEx {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        stack.push(3);
        stack.push(4);
        stack.push(5);

        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
    }
}
```

- Queue는 FIFO(First-In-First-Out)의 자료구조로 예약줄을 생각하면 이해하기 쉽다.

- 예약을 먼저 한 사람이 당연히 먼저 접수가 되듯이 큐에 원소를 먼저 넣게 되면 그 원소가 늦게 넣은 원소에 비해 빠르게 나올 수 있게 된다.

- 큐는 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 먼저 꺼내므로 ArrayList와 같은 배열기반의 컬렉션 클래스를 사용하면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해 데이터의 복사가 발생하므로 비효율적이다.

- 따라서 큐는 ArrayList보다는 LinkedList로 구현하는 것이 더 적합하다고 볼 수 있다.

```java
package collections;

import java.util.LinkedList;
import java.util.Queue;

public class QueueEx {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();

        queue.offer(1);
        queue.offer(2);
        queue.offer(3);

        queue.poll();

        System.out.println(queue);
    }
}
```

---

## Iterator, ListIterator, Enumeration

- Collection 인터페이스에서는 Iterator 인터페이스를 구현한 구현체 클래스의 인스턴스를 반환하는 `iterator()` 메서드를 정의하여 각 요소에 접근하도록 정의하고 있다.

- 따라서 Collections 인터페이스를 상속받는 List, Set 인터페이스에서도 이 메소드를 사용할 수 있다.

- Iterator는 단방향으로만 이동하기 때문에 컬렉션의 마지막 요소에 다다르면 이동할 수 없게 된다.

- Enumeration은 Iterator의 구버전으로 Iterator를 사용하자.

```java
package collections;

import java.util.ArrayList;
import java.util.Iterator;

public class IteratorEx {
    public static void main(String[] args) {
        ArrayList<Integer> al = new ArrayList<>();

        al.add(1);
        al.add(2);
        al.add(3);
        al.add(4);

        Iterator it = al.iterator();
        while (it.hasNext()) {
            Object next = it.next();
            System.out.println(next);
        }
    }
}
```

- Iterator이 단방향으로만 이동할 수 있는 것이라면 ListIterator은 양방향으로 이동할 수 있다.

```java
package collections;

import java.util.ArrayList;
import java.util.ListIterator;

public class ListIteratorEx {
    public static void main(String[] args) {
        ArrayList<Integer> al = new ArrayList<>();

        al.add(1);
        al.add(2);
        al.add(3);

        ListIterator li = al.listIterator();
        while (li.hasNext()) {
            Object obj = li.next();
            System.out.println(obj);
        }

        while (li.hasPrevious()) {
            Object obj = li.previous();
            System.out.println(obj);
        }
    }
}
```

---

## Arrays

- Arrays 클래스에는 배열을 다루는데 유용한 메서드들이 정의되어 있다.

```java
package collections;

import java.util.Arrays;
import java.util.List;

public class ArraysEx {
    public static void main(String[] args) {
        int[] arr = {0, 1, 2, 3, 4};
        int[][] arr2D = {
                {11, 12, 13},
                {21, 22, 23}
        };

        System.out.println("arr = "+ Arrays.toString(arr));
        // Returns a string representation of the "deep contents" of the specified array.
        // If the array contains other arrays as elements, the string representation contains their contents and so on.
        // This method is designed for converting multidimensional arrays to strings.
        System.out.println("arr2D = "+Arrays.deepToString(arr2D));

        // public static int[] copyOf(int[] original, int newLength)
        int[] arr2 = Arrays.copyOf(arr, arr.length);
        System.out.println(Arrays.toString(arr2));

        int[] arr3 = Arrays.copyOf(arr, 3);
        System.out.println(Arrays.toString(arr3));

        int[] arr4 = Arrays.copyOf(arr, 10);
        System.out.println(Arrays.toString(arr4));

        // public static int[] copyOfRange(int[] original,int from,int to)
        int[] arr5 = Arrays.copyOfRange(arr, 1, 4);
        System.out.println(Arrays.toString(arr5));

        int[] arr6 = new int[5];
        // public static void fill(int[] a,int val)
        Arrays.fill(arr6, 10);
        System.out.println(Arrays.toString(arr6));

        int[] arr7 = new int[5];
        // public static void setAll(int[] array,IntUnaryOperator generator)
        Arrays.setAll(arr7, i -> (int)(Math.random()*5+1));
        System.out.println(Arrays.toString(arr7));

        //Interface List<E>
        //E set(int index,E element)
        //Replaces the element at the specified position in this list with the specified element (optional operation).

        //Arrays.asList → mutable(변하기 쉬운)
        //Allows null elements
        List<Integer> l1 = Arrays.asList(1, 2, null);
        l1.set(2, 3);
        System.out.println(l1);

        //List.of → immutable(불변)
        //Not Allow null elements
        List<Integer> l2 = List.of(1, 2, 3);
        //l2.set(2, 10); → UnsupportedOperationException
        System.out.println(l2);

        //Arrays.asList → contain(OK!)
        System.out.println(l1.contains(null));
        //List.of → contains(No!)
        //System.out.println(l2.contains(null)); → NullPointerException

        Integer[] array1 = {1, 2, 3};
        List<Integer> list1 = Arrays.asList(array1);
        array1[1] = 10;
        System.out.println(list1); //[1, 10, 3]

        Integer[] array2 = {1, 2, 3};
        List<Integer> list2 = List.of(array2);
        array2[1] = 10;
        System.out.println(list2); //[1, 2, 3]
    }
}
```

[레퍼런스] : https://docs.oracle.com/javase/8/docs/api/

[레퍼런스] : https://stackoverflow.com/questions/46579074/what-is-the-difference-between-list-of-and-arrays-aslist

---

## Comparator와 Comparable

- 자바 API 문서에 따르면 인터페이스 Comparator의 정의는 다음과 같다.

![캡처](https://github.com/dnwls16071/TIL/assets/106802375/7aaaebf8-cbde-4b74-afd8-b871afa8305a)

```bash
Compares its two arguments for order.
Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.
```

- int타입의 반환값(-1, 0, 1)을 반환하여 대소 관계를 명확히 할 수 있다.

  - 첫 번째 매개변수의 값이 두 번째 매개변수의 값보다 작으면 -1을 반환(Negative)
 
  - 첫 번째 매개변수의 값이 두 번째 매개변수의 값과 같으면 0을 반환(zero)
 
  - 첫 번째 매개변수의 값이 두 번째 매개변수의 값보다 크면 1을 반환(Positive)

- Comparable을 구현한 클래스들이 기본적으로 **오름차순**으로 정렬되어 있지만, 내림차순으로 정렬한다던가 아니면 다른 기준에 의해서 정렬되도록 하고 싶다면 Comparator를 구현해서 정렬기준을 제공할 수 있다.

```bash
Comparable : 기본 정렬기준을 구현하는데 사용됨

Comparator : 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용됨
```

```java
package collections;

import java.util.Arrays;

// 클래스에 Comparable<> 인터페이스를 구현(implements)
class User implements Comparable<User> {
    private String name;
    private int age;

    User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // 비교 로직을 구형
    @Override
    public int compareTo(User user) {
        if (this.age < user.age) {
            return -1;
        } else if (this.age == user.age) {
            return 0;
        } else {
            return 1;
        }
    }
}

public class ComparableEx {
    public static void main(String[] args) {
        User[] users = {
                new User("홍길동", 32),
                new User("김춘추", 64),
                new User("임꺽정", 48),
                new User("박혁거세", 14),
        };
        Arrays.sort(users);
        for (User user : users) {
            System.out.println(user.getName()+", "+user.getAge());
        }
    }
}
```

```java
package collections;

import java.util.Arrays;
import java.util.Comparator;

class Medal {
    private String nation;
    private int gold;
    private int silver;
    private int bronze;

    Medal(String nation, int gold, int silver) {
        this(nation, gold, silver, 0);
    }

    Medal(String nation, int gold, int silver, int bronze) {
        this.nation = nation;
        this.gold = gold;
        this.silver = silver;
        this.bronze = bronze;
    }

    public String getNation() {
        return nation;
    }

    public int getSilver() {
        return silver;
    }

    public int getBronze() {
        return bronze;
    }

    public int getGold() {
        return gold;
    }
}

public class ComparatorEx {
    public static void main(String[] args) {
        Medal[] medals = {
                new Medal("한국", 2, 3, 3),
                new Medal("미국", 2, 4, 3),
                new Medal("캐나다", 1, 2, 5),
                new Medal("기니", 1, 2, 5),
                new Medal("영국", 1, 4),
        };

        // 금메달 순 내림차순 정렬 → 은메달 순 내림차순 정렬 → 동메달 순 내림차순 정렬 → 국가 이름 오름차순 정렬(thenComparing을 체이닝처럼 활용해서 정렬할 수 있음)
        Arrays.sort(medals, Comparator.comparing(Medal::getGold, Comparator.reverseOrder()).thenComparing(Medal::getSilver, Comparator.reverseOrder())
                .thenComparing(Medal::getBronze, Comparator.reverseOrder()).thenComparing(Medal::getNation));

        for (Medal medal : medals) {
            System.out.println(medal.getNation()+","+medal.getGold()+","+medal.getSilver()+","+medal.getBronze());
        }
    }
}
```

--- 

## HashSet

- HashSet은 Set 인터페이스를 구현한 대표적인 컬렉션으로 Set 인터페이스의 특징으로 중복을 허용하지 않는다는 것이다.

- ArrayList와 같이 List 인터페이스를 구현한 컬렉션과 달리 HashSet은 저장순서를 유지하지 않으므로 저장순서를 유지하고자 한다면 LinkedHashSet을 사용해야한다.

```java
package practice3;

import java.util.HashSet;
import java.util.Set;

public class HashSetEx {
    public static void main(String[] args) {
        Object[] objArr = {Integer.valueOf("1"), "1", "2", "2", "3", "3", "3", "3", "4"};
        Set set = new HashSet<>();

        for (int i = 0; i < objArr.length; i++) {
            set.add(objArr[i]);
        }
        System.out.println(set);
    }
}
```

실행 결과
```bash
[1, 1, 2, 3, 4]
```

- objArr의 데이터 타입은 모든 타입의 조상인 Object로 선언하였다.

![캡처](https://github.com/dnwls16071/TIL/assets/106802375/d98aa8b6-28f1-4c31-9db0-6cab73dede29)

- 위의 실행 결과를 보면 1이 두 번 나온 것을 확인할 수 있는데 1의 데이터 타입이 다르기 때문에 중복으로 간주하지 않기 때문에 위와 같은 결과가 나온 것이다.

- `Integer.valueOf("1")`의 경우 Integer 인스턴스를 반환하고 "1"은 String 인스턴스라 다른 것이다.

- Set을 구현한 컬렉션 클래스는 List를 구현한 컬렉션 클래스와 달리 순서를 유지하지 않기 때문에 원했던 저장 순서가 나오는 것을 보장할 수 없다.

- 만일 중복을 제거하는 동시에 저장한 순서를 유지하고자 한다면 HashSet대신 LinkedHashSet을 사용해야 한다.

```java
package practice3;

import java.util.*;

public class HashSetLotto {
    public static void main(String[] args) {
        Set set = new HashSet();

        for (int i = 0; set.size() < 6; i++) {
            int ran = (int) (Math.random() * 45 + 1);
            set.add(ran);
        }

        //public LinkedList(Collection<? extends E> c)
        //Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
        List list = new LinkedList(set);
        Collections.sort(list);
        System.out.println(list);
    }
}
```

```java
package practice3;

import java.util.HashSet;

class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return name + " : " + age;
    }
}

public class HashSetEx2 {
    public static void main(String[] args) {
        HashSet hs = new HashSet();

        hs.add(new String("abc"));
        hs.add(new String("abc"));

        hs.add(new Person("David", 12));
        hs.add(new Person("David", 12));

        System.out.println(hs);
    }
}
```

실행 결과
```bash
[David : 12, abc, David : 12]
```

- Person 클래스는 name과 age라는 멤버변수를 갖는다. 본래 의도는 이름과 나이가 같으면 중복으로 등록되지 않기 위함이었는데 실행 결과를 보면 그렇지 못하다는 것을 알 수 있다.

- HashSet은 **자동으로** 중복을 걸러주는 역할을 한다. 그런데 한 가지 이해가 안되는 부분이 있었다. Person이라는 클래스 내부에 멤버변수와 메서드가 있는데 이 메서드는 인스턴스 객체를 생성해야지 사용할 수 있는 메서드인데 위의 main()에서 메서드를 호출하지 않았는데 어떻게 실행이 되는 것인지 이해가 잘 안 갔다.

- 찾아보니 HashSet은 객체를 추가할 때 내부적으로 해당 객체의 `equals()`와 `hashCode()`메서드를 호출하여 중복을 확인한다고 한다.

- Person클래스에서 오버라이딩한 `equals()`와 `hashCode()`메서드가 호출되어 동등성 비교와 해시 코드의 값을 계산하고 이 과정을 거쳐 동등하며 해시 코드의 값이 같으면 중복을 허용하지 않는 고유한 객체만을 저장하게 되는 것이다.

