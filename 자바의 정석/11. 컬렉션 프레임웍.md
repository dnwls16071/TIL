## 목차

- 컬렉션 프레임웍(Collections Framework)
   - [컬렉션을 위한 자바 인터페이스와 클래스 구성도](#컬렉션을-위한-자바-인터페이스와-클래스-구성도)
   - [컬렉션의 특징](#컬렉션의-특징)
   - [제네릭](#제네릭)
   - [제네릭 타입 매개변수](#제네릭-타입-매개변수)
   - [ArrayList](#ArrayList)
   - [LinkedList](#LinkedList)
   - [Stack과 Queue](#Stack과-Queue)
   - [Iterator, ListIterator, Enumeration](#Iterator-ListIterator-Enumeration)
   - [Arrays](#Arrays)
   - [Comparator와 Comparable](#Comparator와-Comparable)
   - [HashSet](#HashSet)
   - [TreeSet](#TreeSet)
   - [HashMap과 Hashable](#HashMap과-Hashable)
   - [TreeMap](#TreeMap)
   - [Properties](#Properties)
   - [Collections](#Collections)
   - [컬렉션 클래스 정리 & 요약](#컬렉션-클래스-정리--요약)

---

## 컬렉션을 위한 자바 인터페이스와 클래스 구성도

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/b97d2483-c0c0-45c8-a7ab-b9657bbc7056)

- 컬렉션 프레임웍은 크게 Collections 인터페이스와 Map 인터페이스로 나뉜다.

- 그림에서 보이는 Vector, Stack, Hashtable, Properties와 같은 클래스들은 컬렉션 프레임웍이 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임웍의 명명법을 따르지 않는다.

- Vector이나 Hashtable과 같은 기존의 컬렉션 클래스들은 호환을 위해 설계를 변경해서 남겨두었지만 가능하면 사용하지 않는 것이 좋다.

- 대신에 새로 추가된 ArrayList와 HashMap을 사용하길 권장한다.

---

## 컬렉션의 특징

①. 컬렉션은 제네릭(generics)이라는 기법으로 구성되어 있다.

  - 컬렉션 클래스나 인터페이스의 이름에는 항상 <V>, <E>, <K>등이 항상 포함되는데 이를 타입 매개변수라고 한다.

②. 컬렉션의 요소는 객체만 가능하다.

  - int, char, double 등의 기본형 타입의 데이터는 컬렉션의 요소로 불가능하다.

---

## 제네릭

- 제네릭(generics)은 JDK 1.5 버전부터 도입되었다.

- 자바에서 제네릭은 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 말한다.

- 변수를 사용할 때 데이터 타입을 정의한 뒤 사용하듯이 꺽쇠(`< >`)안에 데이터 타입을 지정해서 사용하면 된다.

---

## 제네릭 타입 매개변수

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/50336b30-7f6e-49a3-8344-beadcb35bb5e)

- 꺽쇠(`< >`)안에 데이터 타입을 지정해서 사용한다.

```java
// 제네릭 타입 매개변수에 정수 타입을 할당
FruitBox<Integer> intBox = new FruitBox<>(); 

// 제네릭 타입 매개변수에 실수 타입을 할당
FruitBox<Double> intBox = new FruitBox<>(); 

// 제네릭 타입 매개변수에 문자열 타입을 할당
FruitBox<String> intBox = new FruitBox<>(); 

// 클래스도 넣어줄 수 있다. (Apple 클래스가 있다고 가정)
FruitBox<Apple> intBox = new FruitBox<Apple>();
```

- 이를 그림으로 표현하면 제네릭 타입 전파가 이루어진다고 볼 수 있다. `<T>`부분에서 실행부에서 타입을 받아와 내부에서 `<T>`타입으로 지정한 멤버들에게 전파하여 타입이 구체적으로 설정되는 것이다.

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/7809eca8-0de9-4ba3-921a-c46c7bd399d1)

- 이를 전문 용어로 구체화(Specialization)라고 한다.

- JDK 1.7 버전 이후부터, new 생성자 부분의 제네릭 타입은 생략할 수 있게 되었다.

```java
// new 생성자 부분의 제네릭 타입 생략 가능
FruitBox<Apple> intBox = new FruitBox<>();
```

- 위의 컬렉션의 특징에서 제네릭은 내부에서 사용할 데이터 타입을 외부에서 지정해준다고 했는데 이 제네릭 타입 매개변수로 사용하는 문자가 별도로 정해져있다.

```bash
<E> : Element를 의미하며 컬렉션에서 요소를 의미할 때 사용

<T> : Type을 의미

<V> : Value를 의미

<K> : Key를 의미
```

---

## ArrayList

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/b3811dde-0037-488d-936a-72754a15a032)

- ArrayList는 컬렉션 프레임웍에서 가장 많이 사용되는 컬렉션 클래스 중의 하나로 List 인터페이스를 구현한 구현체 클래스이다.

- 배열을 이용하여 만든 리스트로 **데이터의 저장 순서가 유지되고 중복을 허용한다.**

- 데이터 양에 따라 공간을 유동적으로 변화시킬 수 있다.

- 생성할 때 지정한 크기보다 더 많은 객체를 저장하면 자동적으로 크기가 늘어나기는 하지만 이 과정에서 처리시간이 많이 소요된다.

- 삽입/삭제가 느리다.

```java
package collections;

import java.util.ArrayList;
import java.util.Collections;

public class ArrayListEx {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList(10);

        list.add(1);
        list.add(5);
        list.add(4);
        list.add(3);
        list.add(2);

        Collections.sort(list);
        System.out.println(list);
    }
}
```

[Java API 공식문서] : https://docs.oracle.com/javase/8/docs/api/

--- 

## LinkedList

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/c32912d8-9bb1-4a0c-a032-2167010077d4)

- 배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽어 오는데 걸리는 시간(접근시간, access time)이 가장 빠르다는 장점을 가진다.

- 하지만  배열은 크기를 변경할 수 없고 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 소요된다는 단점이 있다.
  
- 배열의 단점을 보완하기 위하여 링크드 리스트라는 자료구조가 고안되었다. 배열은 모든 데이터가 연속적으로 존재하지만 링크드 리스트는 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성되어 있다.

- 위의 그림에서 알 수 있듯이 하나의 노드에는 데이터와 다음 요소에 대한 참조값(주소값)이 들어있다.

- LinkedList 역시 List 인터페이스를 구현한 것이므로 아래와 같이 List타입의 참조변수로 LinkedList 타입의 인스턴스를 참조할 수 있는 것이다.

```java
package collections;

import java.util.LinkedList;
import java.util.List;

public class LinkedListEx {
    public static void main(String[] args) {
        List<Integer> ll = new LinkedList<>();

        ll.add(1);
        ll.add(2);
        ll.add(3);

        System.out.println(ll.get(0));
    }
}
```

---

## Stack과 Queue

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/36e1b4e2-ba7a-4cfe-8415-44f51c1ea018)

- Stack은 LIFO(Last-In-First-Out)의 자료구조로 연탄을 생각하면 이해하기 쉽다.

- 아궁이에 연탄을 하나씩 쌓게 되면 맨 아래에 있는 연탄을 빼려면 맨 위에 있는 연탄을 빼야한다.

- 따라서 마지막으로 넣은 것이 먼저 나가는 LIFO가 되는 것이다.

- 스택에 원소를 넣을 때는 push연산을, 스택에서 맨 위의 원소를 뺄 때는 pop연산을 한다.

- 스택의 경우 순차적으로 데이터를 추가하고 삭제하기 때문에 ArrayList와 같은 배열기반의 클래스로 구현하기에 적합하다.

```java
package collections;

import java.util.Stack;

public class StackEx {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        stack.push(3);
        stack.push(4);
        stack.push(5);

        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
    }
}
```

- Queue는 FIFO(First-In-First-Out)의 자료구조로 예약줄을 생각하면 이해하기 쉽다.

- 예약을 먼저 한 사람이 당연히 먼저 접수가 되듯이 큐에 원소를 먼저 넣게 되면 그 원소가 늦게 넣은 원소에 비해 빠르게 나올 수 있게 된다.

- 큐는 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 먼저 꺼내므로 ArrayList와 같은 배열기반의 컬렉션 클래스를 사용하면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해 데이터의 복사가 발생하므로 비효율적이다.

- 따라서 큐는 ArrayList보다는 LinkedList로 구현하는 것이 더 적합하다고 볼 수 있다.

```java
package collections;

import java.util.LinkedList;
import java.util.Queue;

public class QueueEx {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();

        queue.offer(1);
        queue.offer(2);
        queue.offer(3);

        queue.poll();

        System.out.println(queue);
    }
}
```

---

## Iterator, ListIterator, Enumeration

- Collection 인터페이스에서는 Iterator 인터페이스를 구현한 구현체 클래스의 인스턴스를 반환하는 `iterator()` 메서드를 정의하여 각 요소에 접근하도록 정의하고 있다.

- 따라서 Collections 인터페이스를 상속받는 List, Set 인터페이스에서도 이 메소드를 사용할 수 있다.

- Iterator는 단방향으로만 이동하기 때문에 컬렉션의 마지막 요소에 다다르면 이동할 수 없게 된다.

- Enumeration은 Iterator의 구버전으로 Iterator를 사용하자.

```java
package collections;

import java.util.ArrayList;
import java.util.Iterator;

public class IteratorEx {
    public static void main(String[] args) {
        ArrayList<Integer> al = new ArrayList<>();

        al.add(1);
        al.add(2);
        al.add(3);
        al.add(4);

        Iterator it = al.iterator();
        while (it.hasNext()) {
            Object next = it.next();
            System.out.println(next);
        }
    }
}
```

- Iterator이 단방향으로만 이동할 수 있는 것이라면 ListIterator은 양방향으로 이동할 수 있다.

```java
package collections;

import java.util.ArrayList;
import java.util.ListIterator;

public class ListIteratorEx {
    public static void main(String[] args) {
        ArrayList<Integer> al = new ArrayList<>();

        al.add(1);
        al.add(2);
        al.add(3);

        ListIterator li = al.listIterator();
        while (li.hasNext()) {
            Object obj = li.next();
            System.out.println(obj);
        }

        while (li.hasPrevious()) {
            Object obj = li.previous();
            System.out.println(obj);
        }
    }
}
```

---

## Arrays

- Arrays 클래스에는 배열을 다루는데 유용한 메서드들이 정의되어 있다.

```java
package collections;

import java.util.Arrays;
import java.util.List;

public class ArraysEx {
    public static void main(String[] args) {
        int[] arr = {0, 1, 2, 3, 4};
        int[][] arr2D = {
                {11, 12, 13},
                {21, 22, 23}
        };

        System.out.println("arr = "+ Arrays.toString(arr));
        // Returns a string representation of the "deep contents" of the specified array.
        // If the array contains other arrays as elements, the string representation contains their contents and so on.
        // This method is designed for converting multidimensional arrays to strings.
        System.out.println("arr2D = "+Arrays.deepToString(arr2D));

        // public static int[] copyOf(int[] original, int newLength)
        int[] arr2 = Arrays.copyOf(arr, arr.length);
        System.out.println(Arrays.toString(arr2));

        int[] arr3 = Arrays.copyOf(arr, 3);
        System.out.println(Arrays.toString(arr3));

        int[] arr4 = Arrays.copyOf(arr, 10);
        System.out.println(Arrays.toString(arr4));

        // public static int[] copyOfRange(int[] original,int from,int to)
        int[] arr5 = Arrays.copyOfRange(arr, 1, 4);
        System.out.println(Arrays.toString(arr5));

        int[] arr6 = new int[5];
        // public static void fill(int[] a,int val)
        Arrays.fill(arr6, 10);
        System.out.println(Arrays.toString(arr6));

        int[] arr7 = new int[5];
        // public static void setAll(int[] array,IntUnaryOperator generator)
        Arrays.setAll(arr7, i -> (int)(Math.random()*5+1));
        System.out.println(Arrays.toString(arr7));

        //Interface List<E>
        //E set(int index,E element)
        //Replaces the element at the specified position in this list with the specified element (optional operation).

        //Arrays.asList → mutable(변하기 쉬운)
        //Allows null elements
        List<Integer> l1 = Arrays.asList(1, 2, null);
        l1.set(2, 3);
        System.out.println(l1);

        //List.of → immutable(불변)
        //Not Allow null elements
        List<Integer> l2 = List.of(1, 2, 3);
        //l2.set(2, 10); → UnsupportedOperationException
        System.out.println(l2);

        //Arrays.asList → contain(OK!)
        System.out.println(l1.contains(null));
        //List.of → contains(No!)
        //System.out.println(l2.contains(null)); → NullPointerException

        Integer[] array1 = {1, 2, 3};
        List<Integer> list1 = Arrays.asList(array1);
        array1[1] = 10;
        System.out.println(list1); //[1, 10, 3]

        Integer[] array2 = {1, 2, 3};
        List<Integer> list2 = List.of(array2);
        array2[1] = 10;
        System.out.println(list2); //[1, 2, 3]
    }
}
```

[레퍼런스] : https://docs.oracle.com/javase/8/docs/api/

[레퍼런스] : https://stackoverflow.com/questions/46579074/what-is-the-difference-between-list-of-and-arrays-aslist

---

## Comparator와 Comparable

- 자바 API 문서에 따르면 인터페이스 Comparator의 정의는 다음과 같다.

![캡처](https://github.com/dnwls16071/TIL/assets/106802375/7aaaebf8-cbde-4b74-afd8-b871afa8305a)

```bash
Compares its two arguments for order.
Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.
```

- int타입의 반환값(-1, 0, 1)을 반환하여 대소 관계를 명확히 할 수 있다.

  - 첫 번째 매개변수의 값이 두 번째 매개변수의 값보다 작으면 -1을 반환(Negative)
 
  - 첫 번째 매개변수의 값이 두 번째 매개변수의 값과 같으면 0을 반환(zero)
 
  - 첫 번째 매개변수의 값이 두 번째 매개변수의 값보다 크면 1을 반환(Positive)

- Comparable을 구현한 클래스들이 기본적으로 **오름차순**으로 정렬되어 있지만, 내림차순으로 정렬한다던가 아니면 다른 기준에 의해서 정렬되도록 하고 싶다면 Comparator를 구현해서 정렬기준을 제공할 수 있다.

```bash
Comparable : 기본 정렬기준을 구현하는데 사용됨

Comparator : 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용됨
```

```java
package collections;

import java.util.Arrays;

// 클래스에 Comparable<> 인터페이스를 구현(implements)
class User implements Comparable<User> {
    private String name;
    private int age;

    User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // 비교 로직을 구형
    @Override
    public int compareTo(User user) {
        if (this.age < user.age) {
            return -1;
        } else if (this.age == user.age) {
            return 0;
        } else {
            return 1;
        }
    }
}

public class ComparableEx {
    public static void main(String[] args) {
        User[] users = {
                new User("홍길동", 32),
                new User("김춘추", 64),
                new User("임꺽정", 48),
                new User("박혁거세", 14),
        };
        Arrays.sort(users);
        for (User user : users) {
            System.out.println(user.getName()+", "+user.getAge());
        }
    }
}
```

```java
package collections;

import java.util.Arrays;
import java.util.Comparator;

class Medal {
    private String nation;
    private int gold;
    private int silver;
    private int bronze;

    Medal(String nation, int gold, int silver) {
        this(nation, gold, silver, 0);
    }

    Medal(String nation, int gold, int silver, int bronze) {
        this.nation = nation;
        this.gold = gold;
        this.silver = silver;
        this.bronze = bronze;
    }

    public String getNation() {
        return nation;
    }

    public int getSilver() {
        return silver;
    }

    public int getBronze() {
        return bronze;
    }

    public int getGold() {
        return gold;
    }
}

public class ComparatorEx {
    public static void main(String[] args) {
        Medal[] medals = {
                new Medal("한국", 2, 3, 3),
                new Medal("미국", 2, 4, 3),
                new Medal("캐나다", 1, 2, 5),
                new Medal("기니", 1, 2, 5),
                new Medal("영국", 1, 4),
        };

        // 금메달 순 내림차순 정렬 → 은메달 순 내림차순 정렬 → 동메달 순 내림차순 정렬 → 국가 이름 오름차순 정렬(thenComparing을 체이닝처럼 활용해서 정렬할 수 있음)
        Arrays.sort(medals, Comparator.comparing(Medal::getGold, Comparator.reverseOrder()).thenComparing(Medal::getSilver, Comparator.reverseOrder())
                .thenComparing(Medal::getBronze, Comparator.reverseOrder()).thenComparing(Medal::getNation));

        for (Medal medal : medals) {
            System.out.println(medal.getNation()+","+medal.getGold()+","+medal.getSilver()+","+medal.getBronze());
        }
    }
}
```

--- 

## HashSet

- HashSet은 Set 인터페이스를 구현한 대표적인 컬렉션으로 Set 인터페이스의 특징으로 중복을 허용하지 않는다는 것이다.

- ArrayList와 같이 List 인터페이스를 구현한 컬렉션과 달리 HashSet은 저장순서를 유지하지 않으므로 저장순서를 유지하고자 한다면 LinkedHashSet을 사용해야한다.

```java
package practice3;

import java.util.HashSet;
import java.util.Set;

public class HashSetEx {
    public static void main(String[] args) {
        Object[] objArr = {Integer.valueOf("1"), "1", "2", "2", "3", "3", "3", "3", "4"};
        Set set = new HashSet<>();

        for (int i = 0; i < objArr.length; i++) {
            set.add(objArr[i]);
        }
        System.out.println(set);
    }
}
```

실행 결과
```bash
[1, 1, 2, 3, 4]
```

- objArr의 데이터 타입은 모든 타입의 조상인 Object로 선언하였다.

![캡처](https://github.com/dnwls16071/TIL/assets/106802375/d98aa8b6-28f1-4c31-9db0-6cab73dede29)

- 위의 실행 결과를 보면 1이 두 번 나온 것을 확인할 수 있는데 1의 데이터 타입이 다르기 때문에 중복으로 간주하지 않기 때문에 위와 같은 결과가 나온 것이다.

- `Integer.valueOf("1")`의 경우 Integer 인스턴스를 반환하고 "1"은 String 인스턴스라 다른 것이다.

- Set을 구현한 컬렉션 클래스는 List를 구현한 컬렉션 클래스와 달리 순서를 유지하지 않기 때문에 원했던 저장 순서가 나오는 것을 보장할 수 없다.

- 만일 중복을 제거하는 동시에 저장한 순서를 유지하고자 한다면 HashSet대신 LinkedHashSet을 사용해야 한다.

```java
package practice3;

import java.util.*;

public class HashSetLotto {
    public static void main(String[] args) {
        Set set = new HashSet();

        for (int i = 0; set.size() < 6; i++) {
            int ran = (int) (Math.random() * 45 + 1);
            set.add(ran);
        }

        //public LinkedList(Collection<? extends E> c)
        //Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
        List list = new LinkedList(set);
        Collections.sort(list);
        System.out.println(list);
    }
}
```

```java
package practice3;

import java.util.HashSet;

class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return name + " : " + age;
    }
}

public class HashSetEx2 {
    public static void main(String[] args) {
        HashSet hs = new HashSet();

        hs.add(new String("abc"));
        hs.add(new String("abc"));

        hs.add(new Person("David", 12));
        hs.add(new Person("David", 12));

        System.out.println(hs);
    }
}
```

실행 결과
```bash
[David : 12, abc, David : 12]
```

- Person 클래스는 name과 age라는 멤버변수를 갖는다. 본래 의도는 이름과 나이가 같으면 중복으로 등록되지 않기 위함이었는데 실행 결과를 보면 그렇지 못하다는 것을 알 수 있다.

- HashSet은 **자동으로** 중복을 걸러주는 역할을 한다. 그런데 한 가지 이해가 안되는 부분이 있었다. Person이라는 클래스 내부에 멤버변수와 메서드가 있는데 이 메서드는 인스턴스 객체를 생성해야지 사용할 수 있는 메서드인데 위의 main()에서 메서드를 호출하지 않았는데 어떻게 실행이 되는 것인지 이해가 잘 안 갔다.

- 찾아보니 HashSet은 객체를 추가할 때 내부적으로 해당 객체의 `equals()`와 `hashCode()`메서드를 호출하여 중복을 확인한다고 한다.

- Person클래스에서 오버라이딩한 `equals()`와 `hashCode()`메서드가 호출되어 동등성 비교와 해시 코드의 값을 계산하고 이 과정을 거쳐 동등하며 해시 코드의 값이 같으면 중복을 허용하지 않는 고유한 객체만을 저장하게 되는 것이다.

- 다음은 Iterator()과 HashSet을 이용한 합집합/차집합/교집합을 만드는 코드이다.

```java
package practice3;

import java.util.HashSet;
import java.util.Iterator;

public class HashSetEx3 {
    public static void main(String[] args) {
        HashSet setA = new HashSet();
        HashSet setB = new HashSet();
        HashSet unionSet = new HashSet();   // 합집합
        HashSet interSet = new HashSet();   // 교집합
        HashSet diffSetA = new HashSet();    // 차집합
        HashSet diffSetB = new HashSet();    // 차집합

        for (int i = 1; i < 4; i++) {
            setA.add(i);
        }

        for (int i = 2; i < 5; i++) {
            setB.add(i);
        }

        // 합집합
        // Collection의 상위 인터페이스 : Iterable<E>
        // 구현한(구현체) 클래스 : ... HashSet
        Iterator it = setA.iterator();
        while (it.hasNext()) {
            unionSet.add(it.next());
        }
        it = setB.iterator();
        while (it.hasNext()) {
            unionSet.add(it.next());
        }

        // 교집합
        it = setA.iterator();
        while (it.hasNext()) {
            Object elm = it.next();
            if (setB.contains(elm)) {
                interSet.add(elm);
            }
        }

        // 차집합(A-B)
        it = setA.iterator();
        while (it.hasNext()) {
            Object elm = it.next();
            if (!setB.contains(elm)) {
                diffSetA.add(elm);
            }
        }

        // 차집합(B-A)
        it = setB.iterator();
        while (it.hasNext()) {=
            Object elm = it.next();
            if (!setA.contains(elm)) {
                diffSetB.add(elm);
            }
        }

        System.out.println(setA);
        System.out.println(setB);
        System.out.println(diffSetA);
        System.out.println(diffSetB);
        System.out.println(interSet);
        System.out.println(unionSet);
    }
}
```

---

## TreeSet

- TreeSet은 이진 검색 트리(Binary Search Tree)라는 자료구조의 형태로 저장하는 컬렉션 클래스이다.

- 이진 검색 트리는 정렬, 검색, 범위 검색에 높은 성능을 보인다.

- 이진 트리는 링크드리스트(LinkedList)처럼 여러 개의 노드가 서로 연결된 구조로 각 노드에 최대 2개의 노드를 연결할 수 있으며 루트라고 불리는 하나의 노드에서부터 시작해서 계속 확장할 수 있다.

![tree_set_1](https://github.com/dnwls16071/TIL/assets/106802375/9556dc9b-9df7-417d-b17e-839d0fcad323)

- 이진 트리의 노드를 표현하면 다음과 같다.

```java
class TreeNode   {
   TreeNode left;   // 왼쪽 자식노드
   Object element;  // 객체를 저장하기 위한 참조변수
   TreeNode right;  //  오른쪽 자식노드
}
```

```java
package practice3;

import java.util.Set;
import java.util.TreeSet;

public class TreeSetEx {
    public static void main(String[] args) {
        Set set = new TreeSet();

        for (int i = 0; set.size() < 6; i++) {
            Object o = (int) (Math.random() * 45 + 1);
            set.add(o);
        }

        System.out.println(set);
    }
}
```

---

## HashMap과 Hashtable

- HashMap은 Map 인터페이스를 구현한 것이다. Map은 키(key)와 값(value)을 묶어서 하나의 데이터(entry)로 저장한다는 특징을 갖는다.

- 그리고 해싱(hashing)을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보인다.

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable
         // ....
```

- HashMap은 키와 값을 Object타입으로 저장한다. 즉, Object의 형태로 저장하기 때문에 모든 타입의 조상이라 어떠한 객체도 저장할 수 있지만 주로 String을 대문자 또는 소문자로 통일해서 사용하곤 한다.

```bash
키(key) : 컬렉션 내의 키(key) 중에서 유일해야 한다.
값(value) : 키와 달리 데이터의 중복을 허용한다.
```

- 키는 저장된 값을 찾는 용도이기에 중복을 허용해선 안 된다.

```java
package practice3;

import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class HashMapEx {
    public static void main(String[] args) {
        HashMap hashMap = new HashMap();
        hashMap.put("test", 1234);
        hashMap.put("test1", 1234);
        hashMap.put("test2", 1234);

        Scanner scanner = new Scanner(System.in);

        while (true) {
            System.out.println("아이디와 패스워드를 입력하세요");
            System.out.print("ID: ");
            String id = scanner.nextLine();

            System.out.print("Password: ");
            Integer password = scanner.nextInt();
            scanner.nextLine();
            System.out.println();

            if (!hashMap.containsKey(id)) {
                System.out.println("입력한 아이디는 존재하지 않습니다.");
                continue;
            }

            //Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
            //HashMap은 위의 설명과 같이 키와 매핑되는 값을 리턴하는데 만약 키와 매핑되는 값이 없으면 null을 리턴한다.
            if (!(hashMap.get(id)).equals(password)) {
                System.out.println("패스워드가 일치하지 않습니다.");
            } else {
                System.out.println("아이디와 패스워드가 일치합니다.");
                break;
            }
        }
    }
}
```

```java
package practice3;

import java.util.*;

public class HashMapEx2 {
    public static void main(String[] args) {
        HashMap hashMap = new HashMap();
        hashMap.put("김자바", 100);
        hashMap.put("강자바", 100);
        hashMap.put("안자바", 90);
        hashMap.put("정자바", 80);

        //public Set<Map.Entry<K,V>> entrySet()
        //Returns a Set view of the mappings contained in this map.
        Set set = hashMap.entrySet();
        Iterator it = set.iterator();

        while (it.hasNext()) {
            Map.Entry e = (Map.Entry) it.next();
            System.out.println("이름: "+e.getKey()+", 점수: "+e.getValue());
        }

        //public Set<K> keySet()
        //Returns a Set view of the keys contained in this map.
        set = hashMap.keySet();
        System.out.println("명단: "+set);

        //public Collection<V> values()
        //Returns a Collection view of the values contained in this map.
        Collection values = hashMap.values();
        System.out.println("점수: "+values);

        it = values.iterator();
        int total = 0;
        while (it.hasNext()) {
            Integer i = (Integer) it.next();
            total += i.intValue();
        }
        System.out.println("최저 점수: "+Collections.min(values));
        System.out.println("최고 점수: "+Collections.max(values));
        System.out.println("평균 점수: "+(double) total / set.size());
    }
}
```

- entrySet()을 이용해서 키와 값을 모두 함께 읽을 수 있고 keySet()이나 valueSet()을 이용해서 키나 값만을 읽는 것도 가능하다.

```java
package practice3;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class HashMapEx3 {
    static HashMap phoneBook = new HashMap();
    public static void main(String[] args) {
        addPhoneNo("친구", "이자바", "010-1111-1111");
        addPhoneNo("친구", "김자바", "010-1111-2222");
        addPhoneNo("친구", "강자바", "010-1111-3333");
        addPhoneNo("회사", "김대리", "010-1111-4444");
        addPhoneNo("회사", "박대리", "010-1111-5555");
        addPhoneNo("회사", "이부장", "010-1111-6666");

        printList();
    }

    // 그룹에 이름, 전화번호를 저장하는 static 메서드
    static void addPhoneNo(String groupName, String name, String tel) {
        addGroup(groupName);
        HashMap group = (HashMap) phoneBook.get(groupName);
        group.put(name, tel);
    }

    static void addPhoneNo(String name, String tel) {
        addPhoneNo("기타", name, tel);
    }

    // 그룹을 추가하는 메서드
    static void addGroup(String groupName) {
        if (!phoneBook.containsKey(groupName)) {
            phoneBook.put(groupName, new HashMap<>());
        }
    }

    // 전화번호부 전체 출력하는 메서드
    static void printList() {
        Set set = phoneBook.entrySet();
        Iterator it = set.iterator();

        while (it.hasNext()) {
            Map.Entry e = (Map.Entry) it.next();
            Set subset = ((HashMap) e.getValue()).entrySet();
            Iterator subit = subset.iterator();
            System.out.println(e.getKey()+"["+subset.size()+"]");

            while (subit.hasNext()) {
                Map.Entry obj = (Map.Entry) subit.next();
                String name = (String) obj.getKey();
                String telNo = (String) obj.getValue();
                System.out.println(name + ", " + telNo);
            }
        }
    }
}
```

- #### ❗해싱과 해시함수

- 해싱이란, 해시함수(hash funciton)를 사용해서 데이터를 해시 테이블(HashTable)에 저장하고 검색하는 기법을 말한다.

- 해시함수는 데이터가 저장되어 있는 곳을 알려주기 때문에 다량의 데이터 중에세도 빠르게 데이터를 찾을 수 있다.

--- 

## TreeMap

- TreeMap은 이름에서 알 수 있듯이 이진검색트리의 형태로 키와 같이 쌍으로 이루어진 데이터를 저장한다.

- 이름에서 알 수 있듯이 이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장한다. 그래서 검색과 정렬에 적합한 컬렉션 클래스이다.

```java
package practice3;

import java.util.*;

public class TreeMapEx {
    public static void main(String[] args) {
        String[] data = {"A", "K", "A", "K", "D", "K", "A", "K", "K", "K", "Z", "D"};

        TreeMap tm = new TreeMap();
        for (int i = 0; i < data.length; i++) {
            if (!tm.containsKey(data[i])) {
                tm.put(data[i], Integer.valueOf(1));
            } else {
                Integer value = (Integer) tm.get(data[i]);
                tm.put(data[i], value.intValue() + 1);
            }
        }

        Iterator it = tm.entrySet().iterator();
        System.out.println("==== 기본 정렬 ====");
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            int value = ((Integer) entry.getValue()).intValue();
            System.out.println(entry.getKey() + " : " + printBar('#', value));
        }

        Set set = tm.entrySet();
        List list = new ArrayList(set);
        Collections.sort(list, new ValueComparator());

        it = list.iterator();
        System.out.println("==== 정렬 후 결과 ====");
        while (it.hasNext()) {
            Map.Entry entry = (Map.Entry) it.next();
            int value = ((Integer) entry.getValue()).intValue();
            System.out.println(entry.getKey() + " : " + printBar('#', value));
        }
    }

    static class ValueComparator implements Comparator {

        @Override
        public int compare(Object o1, Object o2) {
            if (o1 instanceof Map.Entry && o1 instanceof Map.Entry) {
                Map.Entry e1 = (Map.Entry) o1;
                Map.Entry e2 = (Map.Entry) o2;

                int value1 = ((Integer) e1.getValue()).intValue();
                int value2 = ((Integer) e2.getValue()).intValue();
                return value2 - value1;
            } else {
                return -1;
            }
        }
    }

    public static String printBar(char ch, int cnt) {
        char[] bar = new char[cnt];
        for (int i = 0; i < bar.length; i++) {
            bar[i] = ch;
        }
        return new String(bar);
    }
}
```

--- 

## Properties

- Properties는 HashMap의 구버전인 Hashtable을 상속받아 구현한 것으로 Hashtable은 키와 값을 (Object, Object) 형태로 저장하는 반면에 Properties는 (String, String)의 형태로 저장하는 보다 단순화된 컬렉션 클래스이다.

```java
package practice3;

import java.util.Enumeration;
import java.util.Properties;

public class PropertiesEx {
    public static void main(String[] args) {
        Properties prop = new Properties();

        //public Object setProperty(String key, String value)
        prop.setProperty("timeout", "30");
        prop.setProperty("language", "kr");
        prop.setProperty("size", "10");
        prop.setProperty("capacity", "10");

        //Interface Enumeration<E>
        //propertyNames()
        //Returns an enumeration of all the keys in this property list.
        Enumeration e = prop.propertyNames();

        while (e.hasMoreElements()) {
            String element = (String) e.nextElement();
            //getProperty(String key)
            //Searches for the property with the specified key in this property list.
            System.out.println(element + " = " + prop.getProperty(element));
        }

        //setProperty(String key, String value)
        prop.setProperty("size", "20");
        prop.setProperty("capacity", "100");
        e = prop.propertyNames();

        while (e.hasMoreElements()) {
            String element = (String) e.nextElement();
            System.out.println(element + " = " + prop.getProperty(element));
        }
    }
}
```

- 또한 Properties는 Hashtable을 상속받아 구현한 것으로 Map 인터페이스의 특성상 저장 순서를 유지하지 않는다.

- Properties는 컬렉션프레임웍 이전의 구버전이므로 Iterator가 아닌 Enumeration을 사용한다.

- 그리고 list 메서드를 사용하면 Properties에 저장된 모든 데이터를 화면에 편하게 출력할 수 있다.

---

## Collections

- Arrays가 배열과 관련된 메서드를 제공하는 것처럼 Collections는 컬렉션과 관련된 메서드를 제공한다.

- fill(), copy(), sort(), binarySearch() 등의 메서드는 두 클래스에 모두 포함되어 있으며 같은 기능을 한다.

- `java.util.Collection`은 인터페이스이고 `java.util.Collections`는 클래스이다.

#### ❗쓰레드와 프로세스

```
- 프로세스(Process)란 단순히 실행 중인 프로그램이라고 할 수 있다.

- 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말한다.

- 이런 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성된다.

- 쓰레드(Thread)란 프로세스 내에서 실제로 작업을 수행하는 주체를 말한다.

- 모든 프로세스에는 한 개 이상의 쓰레드가 존재하여 작업을 수행하게 된다.

- 두 개 이상의 쓰레드를 가진 프로세스를 멀티 쓰레드 프로세스라고 한다.
```

- 멀티 쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성(consistency)을 유지하는 것이 상당히 중요하다.

- 이 데이터의 일관성을 유지하기 위해서 공유되는 객체에 동기화가 필요하다.

- Collections 클래스는 동기화 메서드(synchronized)를 제공하고 있으므로 동기화가 필요할 때 해당하는 것을 사용하면 된다.

```java
static Collection synchronizedCollection(Collection c)
static List synchronizedList(List list)
static Set synchronizedSet(Set s)
static Map synchronizedMap(Map m)
static SortedSet synchronizedSortedSet(SortedSet s)
static SortedMap synchronizedSortedMap(SortedMap m)
```

- 또한 컬렉션에 저장된 데이터를 보호하기 위해서 컬렉션을 변경할 수 없도록 즉, 읽기 전용으로 만들어야할 때가 있다. 주로 멀티 쓰레드 프로그래밍에서는 여러 쓰레드가 하나의 컬렉션을 공유하다보면 데이터의 손상이 발생할 수 있는데 이를 방지하려면 아래의 메서드들을 사용하면 된다.

```java
static Collection unmodifiableCollection(Collection c)
static List unmodifiableList(List list)
static Set unmodifiableSet(Set s)
static Map unmodifiableMap(Map m)
static NavigableSet unmodifiableNavigableSet(NavigableSet s)
static SortedSet unmodifiableSortedSet(SortedSet s)
static NavigableMap unmodifiableNavigableMap(NavigableMap m)
static SortedMap unmodifiableSortedMap(SortedMap m)
```

- 매번 여러 사용자가 접근할 때마다 객체를 생성하면 그 비용은 무시할 수 없을 정도로 많이 발생하게 된다. 단 하나의 객체만을 저장하는 컬렉션을 만드는 싱글톤 패턴을 적용해서 싱글톤 컬렉션을 만드려면 아래의 메서드를 사용하면 된다.

```java
static List singletonList(Object o)
static Set singletonSet(Object o)
static Map singletonMap(Object key, Object value)
```

- 배열은 동일한 자료형 타입의 데이터만 들어갈 수 있지만 확장에 어려움이 있다고 배웠다. 그래서 나온 것이 컬렉션프레임웍인데 이 컬렉션프레임웍에 모든 종류의 객체를 저장할 수 있다는 것은 장점이기도 하지만 단점이기도 하다. 대부분의 경우 한 종류의 객체를 저장하며, 컬렉션에 지정된 종류의 객체만 저장할 수 있도록 제한하고 싶을 때 아래의 메서드를 사용한다.

```java
static Collection checkedCollection(Collection c, Class type)
static List checkedList(List list, Class type)
static Set checkedSet(Set set, Class type)
static Map checkedMap(Map map, Class keyType, Class valueType)
static Queue checkedQueue(Queu queue, Class type)
static NavigableSet checkedNavigableSet(NavigableSet s, Class type)
static SortedSet checkedSortedSet(SortedSet s, Class type)
static NavigableMap checkedNavigableMap(NavigableMap m, Class keyType, Class valueType)
+static SortedMap checkedSortedMap(SortedMap m, Class keyType, Class valueType)
```

- 아래 코드는 자바 API 문서를 찾아보면서 메서드를 적용한 코드이다.

[참조문서] : https://docs.oracle.com/javase/8/docs/api/

```java
package practice3;

import java.util.ArrayList;
import java.util.List;
import static java.util.Collections.*;

public class CollectionsEx {
    public static void main(String[] args) {
        List list = new ArrayList();
        System.out.println(list);

        //static <T> boolean
        //public static <T> boolean addAll(Collection<? super T> c, T... elements)
        addAll(list, 1, 2, 3, 4, 5);
        System.out.println(list);

        //static void
        //public static void rotate(List<?> list,int distance)
        rotate(list, 1);
        System.out.println(list);

        rotate(list, -1);
        System.out.println(list);

        //static void
        //public static void swap(List<?> list,int i, int j)
        swap(list, 2, 4);
        System.out.println(list);

        //static void
        //shuffle(List<?> list)
        shuffle(list);
        System.out.println(list);

        //static <T extends Comparable<? super T>> void
        //sort(List<T> list)
        sort(list);
        System.out.println(list);

        sort(list, reverseOrder());
        System.out.println(list);

        //public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key)
        int idx = binarySearch(list, 3);
        System.out.println(idx);

        System.out.println("최대값: " + max(list));
        System.out.println("최소값: " + min(list));

        //public static <T> void fill(List<? super T> list, T obj)
        fill(list, 9);
        System.out.println(list);

        //static <T> List<T>
        //public static <T> List<T> nCopies(int n, T o)
        List newList = nCopies(list.size(), 2);
        System.out.println(newList);

        //public static <T> void copy(List<? super T> dest,List<? extends T> src)
        copy(list, newList);

        //public static <T> boolean replaceAll(List<T> list,T oldVal,T newVal)
        replaceAll(list, 2, 1);
        System.out.println(newList);
        System.out.println(list);
    }
}
```

---

## 컬렉션 클래스 정리 & 요약

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/f71b2fe1-7b28-4f6a-9a2d-5017d69db483)

| 컬렉션 | 특징 |
|----------|----------|
| ArrayList | 배열 기반, 데이터의 추가와 삭제에 불리, 순차적인 추가 삭제는 제일 빠름, 임의의 요소에 대한 접근성이 뛰어남 |
| LinkedList | 연결 기반, 데이터의 추가와 삭제에 유리, 임의의 요소에 대한 접근성이 좋지 않음 |
| HashMap | 배열과 연결이 결합된 형태, 추가, 삭제, 검색, 접근성이 모두 뛰어남. 검색에는 최고 성능을 보임 |
| TreeMap | 연결 기반, 정렬과 검색에 적합 |
| Stack | Vector를 상속받아 구현 |
| Queue | LinkedList가 Queue 인터페이스를 구현 |
| Properties | Hashtable을 상속받아 구현 |
| HashSet | HashMap을 이용해서 구현 |
| TreeSet | TreeMap을 이용해서 구현 |
| LinkedHashMap, LinkedHashSet | HashMap, HashSet에 저장순서유지기능 추가 |

