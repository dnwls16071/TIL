## 목차

- java.lang패키지[java.lang패키지]
   - [Object클래스](#Object클래스)
   - [StringBuffer클래스와 StringBuilder클래스](#StringBuffer클래스와-StringBuilder클래스)
   - [Math클래스](#Math클래스)
   - [Wrapper클래스](#Wrapper클래스)
- 유용한 클래스
   - [java.util.regex패키지](#java.util.regex패키지)
   - [java.util.Scanner클래스](#java.util.Scanner클래스)
   - [java.util.StringTokenizer클래스](#java.util.StringTokenizer클래스)
   - [java.math.BigInteger클래스](#java.math.BigInteger클래스)
   - [java.math.BigDecimal클래스](#java.math.BigDecimal클래스)

---

## Object클래스

- Object클래스는 모든 클래스의 최고 조상이기 때문에 Object클래스의 멤버들은 모든 클래스에서 바로 사용 가능하다.

```java
package ch09;

public class EqualsEx1 {
    public static void main(String[] args) {
        Value value1 = new Value(10);
        Value value2 = new Value(10);

        if (value1.equals(value2)) {
            System.out.println("V1과 V2는 같습니다.");
        } else {
            System.out.println("V1과 V2는 다릅니다.");
        }

        value1 = value2;

        if (value1.equals(value2)) {
            System.out.println("V1과 V2는 같습니다.");
        } else {
            System.out.println("V1과 V2는 다릅니다.");
        }
    }
}

class Value {
    int value;

    Value(int value) {
        this.value = value;
    }
}
```

실행 결과

```bash
V1과 V2는 다릅니다.
V1과 V2는 같습니다.
```

- value라는 멤버변수를 가지는 Value클래스를 정의한다. Value타입의 인스턴스 두 개를 생성한 다음 멤버변수의 값으로 동일하게 10을 지정한다.

- 결과를 보면 멤버변수의 값이 같은데도 V1과 V2를 비교했을때 다르다는 결과가 나온다.

- 기본적으로 `equals()`메서드는 주소값으로 비교를 하기 때문에 두 Value타입의 인스턴스의 멤버변수가 값이 같다고 하더라도 주소값이 다르기 때문에 false가 리턴되는 것이다.

- 하지만 `value1 = value2;`를 통해 value2가 가리키는 주소값을 value1이 가리키는 주소값으로 지정해주면 두 Value타입의 인스턴스가 같은 주소값을 가지게 된다.

- value1의 주소값을 x001, value2의 주소값을 x002라고 가정하고 `value1 = value2;`를 해주면 둘 다 x001 주소값을 가지게 되고 x002를 가리키는 인스턴스가 없게 된다.

- Object클래스로부터 상속받은 `equals()`메서드는 주소값으로 비교를 하기 때문에 이 `equals()`메서드를 오버라이딩하여 주소가 아닌 객체에 저장된 내용을 비교하도록 할 수 있다.

```java
package ch09;

public class EqualsEx2 {
    public static void main(String[] args) {
        Person p1 = new Person(1L);
        Person p2 = new Person(1L);

        if (p1 == p2) {
            System.out.println("p1과 p2는 같다.");
        } else {
            System.out.println("p1과 p2는 다르다.");
        }

        if (p1.equals(p2)) {
            System.out.println("p1과 p2는 같다.");
        } else {
            System.out.println("p1과 p2는 다르다.");
        }
    }
}

class Person {
    long id;

    public Person(long id) {
        this.id = id;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj != null && obj instanceof Person) {
            return id == ((Person) obj).id;
        } else {
            return false;
        }
    }
}
```

```java
object instanceof type
```

실행 결과

```bash
p1과 p2는 다르다.
p1과 p2는 같다.
```

- object가 type이거나 type을 상속받는 클래스라면 true를 리턴한다. 그렇지 않으면 false를 리턴한다.

- `equals()`메서드를 오버라이딩하여 서로 다른 참조값을 가지는 인스턴스의 멤버변수를 비교하여 true값을 얻도록 한 것이다.

### hashCode

- `hashCode` : 이 메서드는 해싱(hashing)기법에 사용되는 해시함수를 구현한 것이다.

- 해싱은 데이터관리기법 중의 하나인데 다량의 데이터를 저장하고 검색하는데 유용하다.

- 해시함수는 찾고자하는 값을 입력하면 그 값이 저장된 위치를 알려주는 해시코드(hashcode)를 반환한다.

```java
package ch09;

public class HashCodeEx1 {
    public static void main(String[] args) {
        String str1 = new String("abc");
        String str2 = new String("abc");

        System.out.println(str1.equals(str2));
        System.out.println(str1.hashCode());
        System.out.println(str2.hashCode());
        System.out.println(System.identityHashCode(str1));
        System.out.println(System.identityHashCode(str2));
    }
}
```

- String클래스는 문자열의 내용이 같으면 동일한 해시코드를 반환하도록 hashCode 메서드가 오버라이딩되어 있기 때문에, 문자열의 내용이 같은 str1과 str2에 대해 hashCode()를 호출하면 항상 동일한 해시코드값을 얻는다.

- `System.identityHashCode(Object x)`는 OBject클래스의 hashCode메서드처럼 객체의 주소값으로 해시코드를 생성하기 때문에 모든 객체에 대해 항상 다른 해시코드값을 보장한다.

- 그래서 str1과 str2가 해시코드는 같지만 서로 다른 객체라는 것을 알 수 있다.

```java
package ch09;

public class CardToString {
    public static void main(String[] args) {
        Card c1 = new Card();
        Card c2 = new Card();

        System.out.println(c1.toString());
        System.out.println(c2.toString());
    }
}

class Card {
    String kind;
    int number;

    Card() {
        this("SPADE", 1);
    }

    Card(String kind, int number) {
        this.kind = kind;
        this.number = number;
    }
}
```

### toString

- `toString()`메서드는 인스턴스에 대한 정보를 문자열로 제공할 목적으로 정의한 것이다.

- 인스턴스의 정보를 제공한다는 것은 대부분의 경우 인스턴스 변수에 저장된 값들을 문자열로 표현한다.

- `toString()`메서드를 오버라이딩하여 원하는 정보만을 출력하도록 할 수 있다.

```java
package ch09;

public class CardToString {
    public static void main(String[] args) {
        Card c1 = new Card();
        Card c2 = new Card();

        System.out.println(c1.toString());
        System.out.println(c2.toString());
    }
}

class Card {
    String kind;
    int number;

    Card() {
        this("SPADE", 1);
    }

    Card(String kind, int number) {
        this.kind = kind;
        this.number = number;
    }

    @Override
    public String toString() {
        return "kind: " + kind + ", number: " + number;
    }
}
```

실행 결과

```bash
kind: SPADE, number: 1
kind: SPADE, number: 1
```

### clone()

- `clone()`메서드는 자신을 복제하여 새로운 인스턴스를 생성하는 일을 한다.

- 어떤 인스턴스에 대해 작업을 할 때, 원래의 인스턴스는 보존하고 clone 메서드를 이용해서 새로운 인스턴스를 생성하여 작업을 하면 작업이전의 값이 보존되므로 작업에 실패해서 원래의 상태로 되돌리거나 변경되기 전의 값을 참고하는데 도움이 된다.

- `Cloneable` 인터페이스를 구현한 클래스에서만 클래스에서만 `clone()`를 호출할 수 있다.

- 이 인터페이스를 구현하지 않고 `clone()`을 호출하면 예외가 발생한다.

```java
package ch09;

public class CloneEx1 {
    public static void main(String[] args) {
        Point original = new Point(1, 2);
        Point copy = (Point) original.clone();

        System.out.println("original.x = " + original.x + ", original.y = " + original.y);
        System.out.println("copy.x = " + copy.x + ", copy.y = " + copy.y);
    }
}

class Point implements Cloneable {
    int x;
    int y;

    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return "x = " + x + ", y = " + y;
    }

    @Override
    protected Object clone() {
        Object obj = null;
        try {
            obj = super.clone();
        } catch (CloneNotSupportedException e) {
            System.out.println("에러 = " + e.getMessage());
        }
        return obj;
    }
}
```

---

## StringBuffer클래스와 StringBuilder클래스

- `String`클래스는 불변의 특징이라 인스턴스를 생성할 때 지정된 문자열을 변경할 수 없지만 `StringBuffer`클래스는 변경이 가능하다.

```java
package ch09;

public class StringBufferEx1 {
    public static void main(String[] args) {
        StringBuffer sb1 = new StringBuffer("abc");
        StringBuffer sb2 = new StringBuffer("abc");

        System.out.println("sb1 = " + sb1);
        System.out.println("sb2 = " + sb2);

        if (sb1.equals(sb2)) {
            System.out.println("sb1과 sb2는 같습니다.");
        } else {
            System.out.println("sb1과 sb2는 다릅니다.");
        }
    }
}
```

실행 결과

```bash
sb1 = abc
sb2 = abc
sb1과 sb2는 다릅니다.
```

- `StringBuffer`클래스에서는 `equals()`메서드를 오버라이딩 하지 않아서 `StringBuffer`클래스의 `equals()`메서드를 사용해도 등가 비교 연산자를 이용해서 비교한 결과와 같다.

- `StringBuffer`는 멀티쓰레드에 안전하도록 동기화되어있다. `StringBuffer`에서 동기화 기능을 뺀 것이 바로 `StringBuilder`이다.

```java
package ch09;

public class StringBuilderEx1 {
    public static void main(String[] args) {
        StringBuilder sb1 = new StringBuilder("abc");
        StringBuilder sb2 = new StringBuilder("abc");

        System.out.println("sb1 = " + sb1);
        System.out.println("sb2 = " + sb2);

        if (sb1.equals(sb2)) {
            System.out.println("sb1과 sb2는 같습니다.");
        } else {
            System.out.println("sb1과 sb2는 다릅니다.");
        }
    }
}
```

---

## Math클래스

```java
package ch09;

public class MathEx1 {
    public static void main(String[] args) {
        double val = 90.7552;

        // 소수점 셋째 자리에서 반올림 : 90.76
        val *= 100;
        System.out.println("val = " + val);

        val = (Math.round(val));
        System.out.println("val = " + val);

        val /= 100;
        System.out.println("val = " + val);
    }
}
```

- 소수점 n번째 자리에서 반올림한 값을 얻기 위해서는 `round()`를 사용해야 하는데, 이 메서드는 항상 소수점 첫째자리에서 반올림을 해서 정수값을 결과로 돌려준다.

- 위의 예제는 소수점 셋째자리에서 반올림하여 소수점 둘째자리까지 나타내는 예제다.

- 먼저 100을 곱하고 `round()`메서드를 사용한다.

- 위의 결과를 100으로 나누면 원하는 결과가 나오게 된다.

---

## Wrapper클래스

- 객체지향 개념에서 모든 것은 객체로 다루어져야 한다. 자바에서는 크게 기본형 타입과 참조형 타입으로 나눈다.

- 때로는 기본형 변수도 어쩔 수 없이 객체로 다루어야 하는 경우가 발생한다. 예를 들면 매개변수로 객체를 요구할 때, 객체간의 비교가 필요할 때 등등의 경우에는 기본형 값들을 객체로 변환하여 작업을 수행해야 한다.

- 8개의 기본형을 대표하는 8개의 래퍼 클래스다. 이 클래스를 이용하면 기본형을 객체로 다룰 수 있게 된다.

| 기본형 | 래퍼클래스 | 생성자 |
|:------:|:------:|:------:|
| boolean | Boolean | Boolean(boolean value), Boolean(String s) |
| char | Character| Character(char value) |
| byte | Byte | Byte(byte value), Byte(String s) |
| short | Short | Short(short value), Short(String s) |
| int | Integer | Integer(int value), Integer(String s) |
| long | Long | Long(long value), Long(String s) |
| float | Float | Float(double value), Float(float value), Float(String s) |
| double | Double | Double(double value), Double(String s) |

```java
package ch09;

public class WrapperEx1 {
    public static void main(String[] args) {
        Integer i1 = Integer.valueOf(100);
        Integer i2 = Integer.valueOf(100);

        System.out.println("i1 = " + i1);
        System.out.println("i2 = " + i2);

        if (i1.equals(i2)) {
            System.out.println("i1과 i2는 같습니다.");
        } else {
            System.out.println("i1과 i2는 다릅니다.");
        }
    }
}
```

실행 결과

```bash
i1 = 100
i2 = 100
i1과 i2는 같습니다.
```

```java
public boolean equals(Object obj) {
    if (obj instanceof Integer) {
        return value == ((Integer)obj).intValue();
    }
    return false;
}
```

- Integer Wrapper클래스의 코드 중 일부를 발췌한 것이다.

- 보다시피 객체의 주소가 아닌 객체의 값으로 비교를 하는 것을 볼 수 있다, 따라서 위 코드는 같다는 결과가 나오게 된다.

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/ce4fa1a4-0180-4416-b8a5-498bbd3c74b9)

- 숫자형에서의 오토박싱(auto-boxing)과 언박싱(un-boxing)

- 기본형 → 래퍼 클래스, 래퍼 클래스 → 기본형으로 변환하는 일은 잦다. `new Integer(10)`보다는 `Integer.valueOf(10)`로 박싱을 하고 래퍼 클래스에 있는 기본형 값을 `intValue()`로 꺼낸다.

```java
package ch09;

public class WrapperEx2 {
    public static void main(String[] args) {
        Integer i1 = Integer.valueOf(10);
        System.out.println("i1 = " + i1);

        int value = i1.intValue();
        System.out.println("value = " +value);
    }
}
```

---

## java.util.regex패키지

```java
package ch09;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegularEx1 {
    public static void main(String[] args) {
        String[] data = {
                "bat",
                "baby",
                "bonus",
                "cA",
                "ca",
                "co",
                "c.",
                "c0",
                "car",
                "combat",
                "count",
                "date",
                "disc",
        };

        Pattern p = Pattern.compile("c[a-z]*");

        System.out.println("매칭된 결과 목록");
        for (int i = 0; i < data.length; i++) {
            Matcher m = p.matcher(data[i]);
            if (m.matches()) {
                System.out.println(data[i]);
            }
        }
    }
}
```

- Pattern은 정규식을 정의하는데 사용하고 Matcher는 정규식을 데이터와 비교하는 역할을 수행한다.

