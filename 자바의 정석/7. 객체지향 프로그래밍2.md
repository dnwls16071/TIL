## 목차

- 상속(inheritance)
   - [상속의 정의와 장점](#상속의-정의와-장점)
   - [클래스간의 관계 - 포함관계](#클래스간의-관계---포함관계)
   - [클래스간의 관계 결정하기](#클래스간의-관계-결정하기)
   - [단일상속](#단일상속)
   - [Object클래스 - 모든 클래스의 조상](#Object클래스---모든-클래스의-조상)
- 오버라이딩(Overriding)
   - [오버라이딩이란?](#오버라이딩이란)
   - [오버라이딩의 조건](#오버라이딩의-조건)
   - [오버로딩 vs 오버라이딩](#오버로딩-vs-오버라이딩)
   - [super](#super)
   - [super() - 조상 클래스의 생성자](#super---조상-클래스의-생성자)
- package과 import
   - [패키지(package)](#패키지package)
   - [패키지의 선언](#패키지의-선언)
   - [import문](#import문)
   - [import문의 선언](#import문의-선언)
   - [static import문](#static-import문)
- 제어자(modifier)
   - [제어자란?](#제어자란)
   - [static - 클래스의, 공통적인](#static---클래스의-공통적인)
   - [final - 마지막의, 변경될 수 없는](#final---마지막의-변경될-수-없는)
   - [abstract - 추상의, 미완성의](#abstract---추상의-미완성의)
   - [접근 제어자(access modifier)](#접근-제어자access-modifier)
   - [제어자(modifier)의 조합](#제어자modifier의-조합)
- 다형성(polymorphism)
   - [다형성이란?](#다형성이란)
   - [참조변수의 형변환](#참조변수의-형변환)
   - [instanceof연산자](#instanceof연산자)
   - [참조변수와 인스턴스의 연결](#참조변수와-인스턴스의-연결)
   - [매개변수의 다형성](#매개변수의-다형성)
   - [여러 종류의 객체를 배열로 다루기](#여러-종류의-객체를-배열로-다루기)
- 추상 클래스(abstract class)
   - [추상클래스란?](#추상클래스란)
   - [추상메서드](#추상메서드)
   - [추상클래스의 작성](#추상클래스의-작성)
- 인터페이스(interface)
   - [인터페이스란?](#인터페이스란)
   - [인터페이스의 작성](#인터페이스의-작성)
   - [인터페이스의 상속](#인터페이스의-상속)
   - [인터페이스의 구현](#인터페이스의-구현)
   - [인터페이스를 이용한 다중상속](#인터페이스를-이용한-다중상속)
   - [인터페이스를 이용한 다형성](#인터페이스를-이용한-다형성)
   - [인터페이스의 장점](#인터페이스의-장점)
   - [인터페이스의 이해](#인터페이스의-이해)
   - [디폴트 메서드와 static 메서드](#디폴트-메서드와-static-메서드)

---

## 상속의 정의와 장점

- 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 용이하다.

- 자바에서 상속을 구현하는 방법은 아주 간단하다.

  - 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 `extends` 키워드와 같이 사용하면 된다.
 
```java
class Child extends Parent {
  // ...
}
```

- 조상 클래스(Parent) : 부모 클래스, 상위 클래스, 기반 클래스

- 자손 클래스(Child) : 자식 클래스, 하위 클래스, 파생된 클래스

- A → B : A가 B를 상속받는다.

![images_kongsub_post_bae8097a-c5a8-4025-a817-802e4338ed6d_image](https://github.com/dnwls16071/TIL/assets/106802375/0826a43c-783c-4093-82c0-2ab955963dd2)

```java
package codefactory;

class TvClass {
    boolean power;
    int channel;
    
    void power() {
        power = !power;
    }
    
    void channelUp() {
        channel++;
    }
    
    void channelDown() {
        channel--;
    }
}

class CaptionTV extends TvClass {
    boolean caption;
    
    void displayCaption(boolean caption) {
        if (caption) {
            System.out.println("자막 기능 활성화");
        } else {
            System.out.println("자막 기능 비활성화");
        }
    }
}

public class ex65 {
    public static void main(String[] args) {
        TvClass tvClass = new TvClass();

        // System.out.println(tvClass.caption);
        
        CaptionTV captionTV = new CaptionTV();

        captionTV.power = true;
        captionTV.channel = 10;

        System.out.println("현재 채널 번호 : " + captionTV.channel);
        captionTV.channelUp();
        captionTV.channelUp();
        captionTV.channelUp();
        captionTV.channelUp();
        System.out.println("현재 채널 번호 : " + captionTV.channel);

        System.out.println("자막 기능 활성화를 설정하자.");
        captionTV.displayCaption(captionTV.caption);

        captionTV.caption = false;
        System.out.println("자막 기능이 불편하니까 꺼라.");
        captionTV.displayCaption(captionTV.caption);
    }
}

```

- TvClass와 TvClass를 상속받는 CaptionTv를 만들었다. 

- 위의 코드에서 TvClass를 상속받는 CaptionTv에서는 부모 클래스의 메서드와 필드를 모두 사용할 수 있는데 부모 클래스인 TvClass에서 자식 클래스의 필드인 caption과 메서드인 displayCaption을 사용하지 못하는 것을 알 수 있다.

- **상속 관계에서 자식 클래스의 인스턴스를 생성하면 상속받는 부모 클래스들을 모두 포함한 인스턴스가 생성되지만 부모 클래스의 인스턴스를 생성하면 부모 클래스의 속성과 기능만을 포함하는 인스턴스가 생성된다.**

---

## 클래스간의 관계 - 포함관계

- 상속을 통해 클래스 간에 관계를 맺어 주고 클래스를 재사용하는 방법에 대해서 알아보았다. 상속 이외에도 클래스를 재사용하는 방법이 있는데, 그것은 클래스 간에 포함관계를 맺어주는 것이다.

- 클래스 간의 포함관계를 맺어주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

```java
package codefactory;

class Point {
    int x;
    int y;
}

class Circle {
    Point point = new Point();
    int r;
}


public class ex66 {
    public static void main(String[] args) {
        // ...
    }
}
```

---

## 클래스간의 관계 결정하기

- 클래스를 작성하는데 있어서 상속관계를 맺어 줄 것인지 포함관계를 맺어 줄 것인지 결정하는 것은 때때로 혼란스러울 수 있다.

```bash
(1). 원(Circle)은 점(Point)을 가지고 있다. → 포함 관계

(2). 원(Circle)은 점(Point)이다.          → 상속 관계
```

- 상속 관계의 경우 `is`가 성립하고, 포함 관계의 경우 `has`가 성립한다.

※ 예제 코드 직접 작성하기 - 도형(Shape), 점(Point), 원(Circle), 삼각형(Triangle)

(1). 도형 클래스를 부모 클래스로 작성하고 원, 삼각형 클래스는 부모 클래스를 상속받는다.

(2). 점 클래스는 원, 삼각형 클래스에 포함된다.

```java
package codefactory;

class Shape {
    String color = "Black(검정)";
    void draw() {
        System.out.printf("[color=%s]\n", color);
    }
}

class Point {
    int x;
    int y;

    Point() {
        this(0, 0);
    }

    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class Circle extends Shape {
    Point point = new Point();
    int r;

    Circle() {
        this(new Point(), 100);
    }

    Circle(Point point, int r) {
        this.point= point;
        this.r = r;
    }

    void draw() {
        color = "Red(빨강)";
        System.out.printf("[color=%s]\n", color);
    }
}

class Triangle extends Shape {
    Point[] p = new Point[3];

    Triangle(Point[] p) {
        this.p = p;
    }

    void draw() {
        color = "Orange(주황)";
        System.out.printf("[color=%s]\n", color);
    }
}


public class ex66 {
    public static void main(String[] args) {
        // 원점 기준
        Circle circle1 = new Circle();
        System.out.println(circle1.point);
        System.out.println(circle1.point.x);
        System.out.println(circle1.point.y);
        System.out.println(circle1.r);
        circle1.draw();

        // 특정 점 기준
        Circle circle2 = new Circle(new Point(150, 150), 10);
        System.out.println(circle2.point);
        System.out.println(circle2.point.x);
        System.out.println(circle2.point.y);
        System.out.println(circle2.r);

        // 삼각형
        Point[] p = {new Point(100, 100), new Point(300, 300), new Point(300, 100)};
        Triangle triangle1 = new Triangle(p);
        triangle1.draw();
        System.out.println(triangle1);
        System.out.println(p[0]);
        System.out.println(p[0].x);
        System.out.println(p[0].y);

        System.out.println(p[1]);
        System.out.println(p[1].x);
        System.out.println(p[1].y);

        System.out.println(p[2]);
        System.out.println(p[2].x);
        System.out.println(p[2].y);
    }
}
```

---

## 단일 상속

- 자바에서는 단일 상속만을 허용한다. 그래서 둘 이상의 클래스로부터 상속을 받을 수 없다.

- 예를 들어, TV클래스와 VCR클래스가 있다고 가정할 때, TVCR클래스는 TV클래스와 VCR클래스 중 하나만 선택해야 한다.

- 다중 상속을 허용하면 여러 클래스로부터 상속을 받을 수 있어 복합적인 기능을 가진 코드를 쉽게 작성할 수 있지만 클래스간의 관계가 매우 복잡해진다.

```java
package codefactory;

class Television {
    boolean power;
    int channel;

    void power() {
        power = !power;
    }

    void channelUp() {
        channel++;
    }

    void channelDown() {
        channel--;
    }
}

class VCR {
    boolean power;
    int counter = 0;

    void power() {
        power = !power;
    }

    void play() {
        System.out.println("VCR.play");
    }

    void stop() {
        System.out.println("VCR.stop");
    }

    void rew() {
        System.out.println("VCR.rew");
    }

    void ff() {
        System.out.println("VCR.ff");
    }
}

public class ex67 {
    public static void main(String[] args) {
        // ...
    }
}
```

--- 

## Object클래스 - 모든 클래스의 조상

- Object클래스는 모든 클래스 상속계층도의 최상위에 있는 조상 클래스이다.

- 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object 클래스로부터 상속받게함으로써 가능하게 한다.

![img](https://github.com/dnwls16071/TIL/assets/106802375/b079c6e8-71b0-45bb-b672-9b7272c9bba5)

---

## 오버라이딩이란?

- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다.

- 상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게끔 변경해야하는 경우가 많다. 이럴 때 조상의 메서드를 오버라이딩한다.

---

## 오버라이딩의 조건

- 오버라이딩은 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야 한다.

```bash
자손 클래스에서 오버라이딩하는 메서드의 조상 클래스의 메서드와

- 이름이 같아야 한다.
- 매개변수가 같아야 한다.
- 반환타입이 같아야 한다.
```

---

## 오버로딩 vs 오버라이딩

- 오버로딩과 오버라이딩은 혼동하기 쉽지만, 그 차이는 명백하다.

- 오버로딩은 기존에 없는 새로운 메서드를 추가하는 것이고 오버라이딩은 조상으로부터 상속받은 메서드의 내용을 변경하는 것이다.

---

## super

- super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다.

- 멤버 변수와 지역 변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.

- 조상 클래스로부터 상속받은 멤버도 자손 클래스의 멤버이므로 super대신에 this를 사용하는 것도 가능하다.

- 그래도 조상 클래스와 자손 클래스의 멤버가 중복 정의되어 서로를 구별해야 하는 경우에만 super를 사용하는 것이 좋다.

```java
package codefactory;

class Parent {
    int x = 10;
}

class Child extends Parent {
    int x = 20;
    void ChildMethod() {
        System.out.println("x = " + x);
        System.out.println("this.x = " + this.x);
        System.out.println("super.x = " + super.x);
    }
}

public class ex68 {
    public static void main(String[] args) {
        Child child = new Child();

        child.ChildMethod();
    }
}
```

- 같은 이름의 멤버 변수 x를 조상 클래스와 자손 클래스에서 모두 가지고 있다면 결과는 달라진다.

  - 조상 클래스를 상속받은 자손 클래스에서 x를 출력하면 자손 클래스의 멤버 변수 x가 출력되므로 20이 나온다.  

  - 조상 클래스를 상속받은 자손 클래스에서 this.x를 출력하면 자손 클래스의 멤버 변수 x가 출력되므로 역시 20이 나온다.

  - 조상 클래스를 상속받은 자손 클래스에서 super.x를 출력하면 조상 클래스의 멤버 변수 x의 값인 10이 출력된다.

---

## super() - 조상 클래스의 생성자

- this()와 마찬가지로 super() 역시 생성자이다. **this()는 같은 클래스의 다른 생성자를 호출하는데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.**

- 자손 클래스의 인스턴스를 생성하면 자신의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다. 그래서 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것이다.

- 예를 들어, 2차원 좌표계의 개념을 가지고 있는 Point2D클래스와 3차원 좌표계의 개념을 가지고 있는 Point3D클래스가 있다고 가정하자. Point3D클래스가 Point2D클래스를 상속받게끔 코드를 작성하고 super() 생성자를 활용해 조상 클래스의 생성자를 호출해보자.

```java
package codefactory;

class Point2D {
    int x;
    int y;

    Point2D(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class Point3D extends Point2D {
    int z;

    Point3D(int x, int y, int z) {
        super(x, y);  // super()를 사용해서 부모 클래스인 Point2D 클래스 생성자 호출
        this.z = z;
    }
}

public class ex69 {
    public static void main(String[] args) {
        Point2D point2D = new Point2D(1, 2);
        System.out.println("point2D.x = " + point2D.x);
        System.out.println("point2D.y = " + point2D.y);

        Point3D point3D = new Point3D(1, 2, 3);
        System.out.println("point3D.x = " + point3D.x);
        System.out.println("point3D.y = " + point3D.y);
        System.out.println("point3D.z = " + point3D.z);
    }
}
```

---

## 패키지(package)

- 패키지란 클래스의 묶음이다. 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.

- 같은 이름의 클래스일지라도 서로 다른 패키지에 존재하는 것이 가능하다.

---

## 패키지의 선언

- 패키지를 선언하는 것은 간단하다.

```java
package 패키지명;
```

---

## import문

- 소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다. 하지만 매번 패키지명을 붙여서 작성하기란 여간 불편한 일이 아니다.

- 클래스의 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스 이름에서 패키지명은 생략할 수 있다.

- import문의 역할은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것이다.

---

## import문의 선언

- import문을 선언하는 방법은 다음과 같다.

```java
import 패키지명.클래스명;

import 패키지명.*;
```

---

## static import문

- import문을 사용하면 클래스와 패키지명을 생략할 수 있는 것과 같이 static import문을 사용하면 static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

  ```java
  import static java.lang.Integer.*;
  ```

  ---

  ## 제어자란?

  - 제어자(modifier)는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 제어자의 종류로는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.
 
  - 제어자는 클래스나 멤버 변수에 주로 사용되며, 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.
 
  - 단, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다.
 
  ---

  ## static - 클래스의, 공통적인
  




