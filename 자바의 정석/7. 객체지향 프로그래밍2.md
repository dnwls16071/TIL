## 목차

- 상속(inheritance)
   - [상속의 정의와 장점](#상속의-정의와-장점)
   - [클래스간의 관계 - 포함관계](#클래스간의-관계---포함관계)
   - [클래스간의 관계 결정하기](#클래스간의-관계-결정하기)
   - [단일 상속](#단일-상속)
   - [Object 클래스](#Object-클래스)
- 오버라이딩(Overriding)
   - [오버라이딩이란?](#오버라이딩이란)
   - [오버라이딩의 조건](#오버라이딩의-조건)
   - [오버로딩 vs 오버라이딩](#오버로딩-vs-오버라이딩)
   - [super](#super)
   - [super() - 조상 클래스의 생성자](#super---조상-클래스의-생성자)
- package과 import
   - [패키지(package)](#패키지package)
   - [패키지의 선언](#패키지의-선언)
   - [import문](#import문)
   - [import문의 선언](#import문의-선언)
   - [static import문](#static-import문)
- 제어자(modifier)
   - [제어자란?](#제어자란)
   - [static - 클래스의, 공통적인](#static---클래스의-공통적인)
   - [final - 마지막의, 변경될 수 없는](#final---마지막의-변경될-수-없는)
   - [abstract - 추상의, 미완성의](#abstract---추상의-미완성의)
   - [접근 제어자(access modifier)](#접근-제어자access-modifier)
- 다형성(polymorphism)
   - [다형성이란?](#다형성이란)
   - [참조변수의 형변환](#참조변수의-형변환)
   - [instanceof 연산자](#instanceof-연산자)
   - [참조변수와 인스턴스의 연결](#참조변수와-인스턴스의-연결)
   - [매개변수의 다형성](#매개변수의-다형성)
   - [여러 종류의 객체를 배열로 다루기](#여러-종류의-객체를-배열로-다루기)
- 추상 클래스(abstract class)
   - [추상클래스란?](#추상클래스란)
   - [추상메서드](#추상메서드)
   - [추상클래스의 작성](#추상클래스의-작성)
- 인터페이스(interface)
   - [인터페이스란?](#인터페이스란)
   - [인터페이스의 작성](#인터페이스의-작성)
   - [인터페이스의 상속](#인터페이스의-상속)
   - [인터페이스의 구현](#인터페이스의-구현)
   - [인터페이스를 이용한 다중상속](#인터페이스를-이용한-다중상속)
   - [인터페이스를 이용한 다형성](#인터페이스를-이용한-다형성)
   - [인터페이스의 장점](#인터페이스의-장점)
   - [인터페이스의 이해](#인터페이스의-이해)
   - [디폴트 메서드와 static 메서드](#디폴트-메서드와-static-메서드)

---

## 상속의 정의와 장점

- 상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 용이하다.

- 자바에서 상속을 구현하는 방법은 아주 간단하다.

  - 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 `extends` 키워드와 같이 사용하면 된다.
 
```java
class Child extends Parent {
  // ...
}
```

- 조상 클래스(Parent) : 부모 클래스, 상위 클래스, 기반 클래스

- 자손 클래스(Child) : 자식 클래스, 하위 클래스, 파생된 클래스

- A → B : A가 B를 상속받는다.

![images_kongsub_post_bae8097a-c5a8-4025-a817-802e4338ed6d_image](https://github.com/dnwls16071/TIL/assets/106802375/0826a43c-783c-4093-82c0-2ab955963dd2)

```java
package codefactory;

class TvClass {
    boolean power;
    int channel;
    
    void power() {
        power = !power;
    }
    
    void channelUp() {
        channel++;
    }
    
    void channelDown() {
        channel--;
    }
}

class CaptionTV extends TvClass {
    boolean caption;
    
    void displayCaption(boolean caption) {
        if (caption) {
            System.out.println("자막 기능 활성화");
        } else {
            System.out.println("자막 기능 비활성화");
        }
    }
}

public class ex65 {
    public static void main(String[] args) {
        TvClass tvClass = new TvClass();

        // System.out.println(tvClass.caption);
        
        CaptionTV captionTV = new CaptionTV();

        captionTV.power = true;
        captionTV.channel = 10;

        System.out.println("현재 채널 번호 : " + captionTV.channel);
        captionTV.channelUp();
        captionTV.channelUp();
        captionTV.channelUp();
        captionTV.channelUp();
        System.out.println("현재 채널 번호 : " + captionTV.channel);

        System.out.println("자막 기능 활성화를 설정하자.");
        captionTV.displayCaption(captionTV.caption);

        captionTV.caption = false;
        System.out.println("자막 기능이 불편하니까 꺼라.");
        captionTV.displayCaption(captionTV.caption);
    }
}

```

- TvClass와 TvClass를 상속받는 CaptionTv를 만들었다. 

- 위의 코드에서 TvClass를 상속받는 CaptionTv에서는 부모 클래스의 메서드와 필드를 모두 사용할 수 있는데 부모 클래스인 TvClass에서 자식 클래스의 필드인 caption과 메서드인 displayCaption을 사용하지 못하는 것을 알 수 있다.

- **상속 관계에서 자식 클래스의 인스턴스를 생성하면 상속받는 부모 클래스들을 모두 포함한 인스턴스가 생성되지만 부모 클래스의 인스턴스를 생성하면 부모 클래스의 속성과 기능만을 포함하는 인스턴스가 생성된다.**

---

## 클래스간의 관계 - 포함관계

- 상속을 통해 클래스 간에 관계를 맺어 주고 클래스를 재사용하는 방법에 대해서 알아보았다. 상속 이외에도 클래스를 재사용하는 방법이 있는데, 그것은 클래스 간에 포함관계를 맺어주는 것이다.

- 클래스 간의 포함관계를 맺어주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

```java
package codefactory;

class Point {
    int x;
    int y;
}

class Circle {
    Point point = new Point();
    int r;
}


public class ex66 {
    public static void main(String[] args) {
        // ...
    }
}
```

---

## 클래스간의 관계 결정하기

- 클래스를 작성하는데 있어서 상속관계를 맺어 줄 것인지 포함관계를 맺어 줄 것인지 결정하는 것은 때때로 혼란스러울 수 있다.

```bash
(1). 원(Circle)은 점(Point)을 가지고 있다. → 포함 관계

(2). 원(Circle)은 점(Point)이다.          → 상속 관계
```

- 상속 관계의 경우 `is`가 성립하고, 포함 관계의 경우 `has`가 성립한다.

※ 예제 코드 직접 작성하기 - 도형(Shape), 점(Point), 원(Circle), 삼각형(Triangle)

(1). 도형 클래스를 부모 클래스로 작성하고 원, 삼각형 클래스는 부모 클래스를 상속받는다.

(2). 점 클래스는 원, 삼각형 클래스에 포함된다.

```java
package codefactory;

class Shape {
    String color = "Black(검정)";
    void draw() {
        System.out.printf("[color=%s]\n", color);
    }
}

class Point {
    int x;
    int y;

    Point() {
        this(0, 0);
    }

    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class Circle extends Shape {
    Point point = new Point();
    int r;

    Circle() {
        this(new Point(), 100);
    }

    Circle(Point point, int r) {
        this.point= point;
        this.r = r;
    }

    void draw() {
        color = "Red(빨강)";
        System.out.printf("[color=%s]\n", color);
    }
}

class Triangle extends Shape {
    Point[] p = new Point[3];

    Triangle(Point[] p) {
        this.p = p;
    }

    void draw() {
        color = "Orange(주황)";
        System.out.printf("[color=%s]\n", color);
    }
}


public class ex66 {
    public static void main(String[] args) {
        // 원점 기준
        Circle circle1 = new Circle();
        System.out.println(circle1.point);
        System.out.println(circle1.point.x);
        System.out.println(circle1.point.y);
        System.out.println(circle1.r);
        circle1.draw();

        // 특정 점 기준
        Circle circle2 = new Circle(new Point(150, 150), 10);
        System.out.println(circle2.point);
        System.out.println(circle2.point.x);
        System.out.println(circle2.point.y);
        System.out.println(circle2.r);

        // 삼각형
        Point[] p = {new Point(100, 100), new Point(300, 300), new Point(300, 100)};
        Triangle triangle1 = new Triangle(p);
        triangle1.draw();
        System.out.println(triangle1);
        System.out.println(p[0]);
        System.out.println(p[0].x);
        System.out.println(p[0].y);

        System.out.println(p[1]);
        System.out.println(p[1].x);
        System.out.println(p[1].y);

        System.out.println(p[2]);
        System.out.println(p[2].x);
        System.out.println(p[2].y);
    }
}
```

---

## 단일 상속

- 자바에서는 단일 상속만을 허용한다. 그래서 둘 이상의 클래스로부터 상속을 받을 수 없다.

- 예를 들어, TV클래스와 VCR클래스가 있다고 가정할 때, TVCR클래스는 TV클래스와 VCR클래스 중 하나만 선택해야 한다.

- 다중 상속을 허용하면 여러 클래스로부터 상속을 받을 수 있어 복합적인 기능을 가진 코드를 쉽게 작성할 수 있지만 클래스간의 관계가 매우 복잡해진다.

```java
package codefactory;

class Television {
    boolean power;
    int channel;

    void power() {
        power = !power;
    }

    void channelUp() {
        channel++;
    }

    void channelDown() {
        channel--;
    }
}

class VCR {
    boolean power;
    int counter = 0;

    void power() {
        power = !power;
    }

    void play() {
        System.out.println("VCR.play");
    }

    void stop() {
        System.out.println("VCR.stop");
    }

    void rew() {
        System.out.println("VCR.rew");
    }

    void ff() {
        System.out.println("VCR.ff");
    }
}

public class ex67 {
    public static void main(String[] args) {
        // ...
    }
}
```

--- 

## Object 클래스

- Object 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상 클래스이다.

- 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object 클래스로부터 상속받게함으로써 가능하게 한다.

![img](https://github.com/dnwls16071/TIL/assets/106802375/b079c6e8-71b0-45bb-b672-9b7272c9bba5)

---

## 오버라이딩이란?

- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다.

- 상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스 자신에 맞게끔 변경해야하는 경우가 많다. 이럴 때 조상의 메서드를 오버라이딩한다.

---

## 오버라이딩의 조건

- 오버라이딩은 메서드의 내용만을 새로 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야 한다.

```bash
자손 클래스에서 오버라이딩하는 메서드의 조상 클래스의 메서드와

- 이름이 같아야 한다.
- 매개변수가 같아야 한다.
- 반환타입이 같아야 한다.
```

---

## 오버로딩 vs 오버라이딩

- 오버로딩과 오버라이딩은 혼동하기 쉽지만, 그 차이는 명백하다.

- 오버로딩은 기존에 없는 새로운 메서드를 추가하는 것이고 오버라이딩은 조상으로부터 상속받은 메서드의 내용을 변경하는 것이다.

---

## super

- super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다.

- 멤버 변수와 지역 변수의 이름이 같을 때 this를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super를 붙여서 구별할 수 있다.

- 조상 클래스로부터 상속받은 멤버도 자손 클래스의 멤버이므로 super대신에 this를 사용하는 것도 가능하다.

- 그래도 조상 클래스와 자손 클래스의 멤버가 중복 정의되어 서로를 구별해야 하는 경우에만 super를 사용하는 것이 좋다.

```java
package codefactory;

class Parent {
    int x = 10;
}

class Child extends Parent {
    int x = 20;
    void ChildMethod() {
        System.out.println("x = " + x);
        System.out.println("this.x = " + this.x);
        System.out.println("super.x = " + super.x);
    }
}

public class ex68 {
    public static void main(String[] args) {
        Child child = new Child();

        child.ChildMethod();
    }
}
```

- 같은 이름의 멤버 변수 x를 조상 클래스와 자손 클래스에서 모두 가지고 있다면 결과는 달라진다.

  - 조상 클래스를 상속받은 자손 클래스에서 x를 출력하면 자손 클래스의 멤버 변수 x가 출력되므로 20이 나온다.  

  - 조상 클래스를 상속받은 자손 클래스에서 this.x를 출력하면 자손 클래스의 멤버 변수 x가 출력되므로 역시 20이 나온다.

  - 조상 클래스를 상속받은 자손 클래스에서 super.x를 출력하면 조상 클래스의 멤버 변수 x의 값인 10이 출력된다.

---

## super() - 조상 클래스의 생성자

- this()와 마찬가지로 super() 역시 생성자이다. **this()는 같은 클래스의 다른 생성자를 호출하는데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.**

- 자손 클래스의 인스턴스를 생성하면 자신의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다. 그래서 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용할 수 있는 것이다.

- 예를 들어, 2차원 좌표계의 개념을 가지고 있는 Point2D클래스와 3차원 좌표계의 개념을 가지고 있는 Point3D클래스가 있다고 가정하자. Point3D클래스가 Point2D클래스를 상속받게끔 코드를 작성하고 super() 생성자를 활용해 조상 클래스의 생성자를 호출해보자.

```java
package codefactory;

class Point2D {
    int x;
    int y;

    Point2D(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class Point3D extends Point2D {
    int z;

    Point3D(int x, int y, int z) {
        super(x, y);  // super()를 사용해서 부모 클래스인 Point2D 클래스 생성자 호출
        this.z = z;
    }
}

public class ex69 {
    public static void main(String[] args) {
        Point2D point2D = new Point2D(1, 2);
        System.out.println("point2D.x = " + point2D.x);
        System.out.println("point2D.y = " + point2D.y);

        Point3D point3D = new Point3D(1, 2, 3);
        System.out.println("point3D.x = " + point3D.x);
        System.out.println("point3D.y = " + point3D.y);
        System.out.println("point3D.z = " + point3D.z);
    }
}
```

---

## 패키지(package)

- 패키지란 클래스의 묶음이다. 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.

- 같은 이름의 클래스일지라도 서로 다른 패키지에 존재하는 것이 가능하다.

---

## 패키지의 선언

- 패키지를 선언하는 것은 간단하다.

```java
package 패키지명;
```

---

## import문

- 소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야 한다. 하지만 매번 패키지명을 붙여서 작성하기란 여간 불편한 일이 아니다.

- 클래스의 코드를 작성하기 전에 import문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스 이름에서 패키지명은 생략할 수 있다.

- import문의 역할은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공하는 것이다.

---

## import문의 선언

- import문을 선언하는 방법은 다음과 같다.

```java
import 패키지명.클래스명;

import 패키지명.*;
```

---

## static import문

- import문을 사용하면 클래스와 패키지명을 생략할 수 있는 것과 같이 static import문을 사용하면 static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

  ```java
  import static java.lang.Integer.*;
  ```

---

## 제어자란?

- 제어자(modifier)는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 제어자의 종류로는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

- 제어자는 클래스나 멤버 변수에 주로 사용되며, 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.

- 단, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다.

---

## static - 클래스의, 공통적인

- static은 '클래스의', '공통적인' 의미를 가지고 있다.

- 인스턴스변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지하지만, 클래스변수(static멤버변수)는 인스턴스에 관계없이 같은 값을 갖는다. 그 이유는 하나의 변수를 모든 인스턴스가 공유하기 때문이다.

- static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계되었기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.

- static 제어자

   - 멤버변수
 
      - 모든 인스턴스에 공통적으로 사용되는 클래스변수가 된다.
    
      - 클래스변수는 인스턴스를 생성하지 않고도 사용 가능하다.
    
      - 클래스는 메모리에 로드될 때 생성된다.
 
   - 메서드

      - 인스턴스를 생성하지 않고도 호출 가능한 static 메서드가 된다.
    
      - static 메서드 내에서는 인스턴스 멤버들을 사용할 수 없다.

- 인스턴스멤버의 경우 힙 영역에서 관리되고 클래스멤버의 경우 메서드 영역에서 관리됨

---

## final - 마지막의, 변경될 수 없는

- final은 '마지막의', '변경될 수 없는'의 의미를 가지고 있으며 거의 모든 대상에 사용될 수 있다.

- 변수에 사용되면 값을 변경할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없게 되고 클래스에 사용되면 자신을 확장하는 자손 클래스를 정의하지 못하게 된다.

- final 제어자

   - 클래스
 
      - 변경될 수 없는 클래스, 확장할 수 없는 클래스가 된다.
    
      - 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
    
   - 메서드
 
      - 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다.
    
   - 멤버변수, 지역변수
 
      - 변수 앞에 final이 붙으면 값을 변경할 수 없는 상수가 된다.     

- 생성자를 이용한 final멤버 변수의 초기화

- final이 붙은 변수는 상수이므로 일반적으로 선언과 초기화를 동시에 하지만, 인스턴스 변수의 경우 생성자에서 초기화 되도록 할 수 있다.

```java
package codefactory;

class TestCard {
    final int NUMBER;
    final String KIND;
    static int WIDTH = 100;
    static int HEIGHT = 200;

    TestCard() {
        this(1, "HEART");
    }

    TestCard(int NUMBER, String KIND) {
        this.NUMBER = NUMBER;
        this.KIND = KIND;
    }
}
public class ex70 {
    public static void main(String[] args) {
        TestCard testCard = new TestCard(10, "SPADE");
        TestCard testCard1 = new TestCard();

        System.out.println(testCard.KIND);
        System.out.println(testCard.NUMBER);

        System.out.println(testCard1.KIND);
        System.out.println(testCard1.NUMBER);
    }
}
```

---

## abstract - 추상의, 미완성의

- abstract는 '미완성'의 의미를 가지고 있다. 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.

- 자바에서 추상 클래스, 추상 메서드로 사용하려면 abstract 키워드를 붙인다.
  
---

## 접근 제어자(access modifier)

- 접근 제어자는 멤버 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

| 제어자 | 같은 클래스 | 같은 패키지 | 자손 클래스 | 전체 |
|-----------|-----------|-----------|-----------|-----------|
| public | O | O | O | O |
| protected  | O | O | O(상속) | X |
| default | O | O  | X | X |
| private | O | X | X | X |

- 모두에게 개방적인 접근 제어자는 public, 가장 강력한 접근 제어자는 private이다.

- public은 접근 제한이 전혀 없는 것이고, private는 같은 클래스 내에서만 사용하도록 제한하는 가장 높은 제한이다.

- default는 같은 패키지 내의 클래스에서만 접근이 가능하도록 하는 것이다.

- protected는 default와 비슷하지만 하나 더 추가되었다면 상속 관계에서도 적용이 된다는 것이다.

- 접근 제어자를 이용한 캡슐화

   - 클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.
 
   - 데이터가 유효한 값을 유지하도록, 또는 비밀번호와 같은 데이터를 외부에서 함부로 변경하지 못하도록 하기 위해서 외부로부터의 접근을 제한하는 것이 필요하다.
 
   - 이것을 데이터 감추기, 데이터 은닉, 객체지향개념의 캡슐화(Encapsulation)라고 한다.
 
   - 외부에서 접근할 필요가 없는 멤버들을 private으로 지정하여 외부에 노출시키지 않음으로써 복잡성을 줄일 수 있다.
 
```java
package codefactory;

public class TimeMain {
    public static void main(String[] args) {
        Time time = new Time();

        time.setHour(2);
        time.setMinute(50);
        time.setSecond(14);

        System.out.println(time);

        time.setHour(time.getHour() + 1);
        System.out.println(time);

        // hour의 접근 제어자가 private이므로 외부에서 접근이 불가능하다.
        // 따라서, 게터세터(Getter/Setter)로 값을 읽고 쓴다.
        // time.hour = 13;
    }
}
```

---

## 다형성이란

- 객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.

- 이를 좀 더 구체적으로 표현하면 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 하였다는 것이다.

- 예를 들어, Tv클래스와 CaptionTv클래스가 존재하고 CaptionTv클래스가 Tv클래스를 상속받는다고 가정하자.

```java
package codefactory;

class Parent1 {
    int x;
}

class Child1 extends Parent1 {
    int x;
}

public class ex72 {
    public static void main(String[] args) {
        Parent1 parent1 = new Parent1();
        Child1 child1 = new Child1();
        // Child1 child2 = new Parent1();
        Parent1 parent2 = new Child1();
    }
}
```

- 조상 타입의 참조변수로 자손 타입의 인스턴스를 참조할 수 있다.

- 반대로 자손 타입의 참조변수로 조상 타입의 인스턴스를 참조할 수 없다.

```bash
조상타입 변수명 = new 자손타입 → 다형성을 활용
```

---

## 참조변수의 형변환

- 서로 상속관계에 있는 클래스 사이에서만 가능하기 때문에 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환만 가능하다.

---

## instanceof 연산자

- instanceof의 왼쪽에는 참조변수를 오른쪽에는 타입이 피연산자로 위치한다.

- 그리고 연산의 결과로 boolean값인 true와 false 중의 하나를 반환한다.

- instanceof 연산자를 이용한 연산 결과로 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

---

## 참조변수와 인스턴스의 연결

```java
package codefactory;

class Parent2 {
    int x = 100;

    void method() {
        System.out.println("parent.method");
    }
}

class Child2 extends Parent2 {
    int x = 200;

    void method() {
        System.out.println("child.method");
    }
}

public class ex73 {
    public static void main(String[] args) {
        Parent2 p = new Child2();
        Child2 c = new Child2();

        System.out.println(p.x);
        p.method();

        System.out.println(c.x);
        c.method();
    }
}
```

- 메서드의 경우 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 항상 오버라이딩된 메서드가 출력된다. 하지만, 멤버변수의 경우 참조변수의 타입에 따라 달라진다.

```bash
100
child.method
200
child.method
```

- 위의 코드의 실행 결과이다. `Parent2`클래스와 `Child2`클래스가 같은 멤버 변수를 선언하고 있는데 조상 타입이 `Parent2`인 경우 멤버 변수를 출력하면 `Parent2`의 멤버 변수값인 100이 출력되고 조상 타입이 `Child2`인 경우 멤버 변수를 출력하면 `Child2`의 멤버 변수값인 200이 출력된다. 하지만 메서드의 경우 조상 타입과 관계없이 오버라이딩된 메서드가 출력된다.

--- 

## 매개변수의 다형성

```java
package codefactory;

class Product {
    int price;
    int bonusPoint;

    Product(int price, int bonusPoint) {
        this.price = price;
        this.bonusPoint = bonusPoint;
    }
}

class Buyer {
    int money = 10000;
    int bonusPoint = 0;

    void buyProduct(Product p) {
        money -= p.price;
        bonusPoint += p.bonusPoint;
    }
}

class Audio extends Product {
    Audio() {
        super(5000, 50);
    }
}

class Refrigerator extends Product {
    Refrigerator() {
        super(3000, 30);
    }
}

public class ex74 {
    public static void main(String[] args) {
        Buyer buyer = new Buyer();

        buyer.buyProduct(new Audio());
        System.out.println("현재 금액 : " + buyer.money);
        System.out.println("현재 보너스포인트 : " + buyer.bonusPoint);

        buyer.buyProduct(new Refrigerator());
        System.out.println("현재 금액 : " + buyer.money);
        System.out.println("현재 보너스포인트 : " + buyer.bonusPoint);
    }
}
```

- 제품을 직접 대입해 코드를 작성하게 된다면 코드의 유지보수가 어려울 것이다. 다형성을 활용해서 작성하면 유지 보수가 용이하다.

---

## 여러 종류의 객체를 배열로 다루기

- 조상 타입의 참조변수로 자식 타입의 객체를 참조하는 것이 가능하므로 Audio, Refrigerator 등의 상위 클래스는 Product클래스로 이 클래스 타입의 배열을 만들 수 있다.

```java
package codefactory;

import java.util.Scanner;

class Sports {
    String name;
    int participant;
}

class Baseball extends Sports {
    Baseball() {
        this("LG", 9);
    }
    Baseball(String name, int participant) {
        this.name = name;
        this.participant = participant;
    }
}

class Soccer extends Sports {
    Soccer() {
        this("맨체스터 시티", 11);
    }
    Soccer(String name, int participant) {
        this.name = name;
        this.participant = participant;
    }
}

public class ex75 {
    public static void main(String[] args) {
        Sports[] array = {new Baseball(), new Soccer(), new Baseball("삼성", 9), new Soccer("수원 삼성", 11)};
        for (Sports sports : array) {
            System.out.println("sports.name = " + sports.name + ", sports.participant = " + sports.participant);
        }
    }
}
```

---

## 추상클래스란?

- 클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다.

- 미완성 설계도란 단어의 뜻 그대로 완성되지 못한 채로 남겨진 설계도를 의미한다.

- 설계도가 미완성이라는 것은 멤버의 개수에 관계된 것이 아니라 단지 미완성 메서드(추상메서드)를 포함하고 있다는 뜻이다.

- 미완성 설계도로 완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스를 생성할 수 없다. 추상클래스는 상속을 통해서 자손 클래스에 의해서 완성된다.

- 추상 클래스는 키워드 abstract를 붙이면 된다.

---

## 추상메서드

- 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨두는 것이 추상 메서드이다.

- 설계만 해 놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드인 것이다.

- 추상 메서드 역시 앞에 abstract 키워드를 붙이고 문장의 끝을 알리는 세미콜론을 찍어준다.

---

## 추상클래스의 작성

- 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업을 추상화라고 하고 상속을 통해 클래스를 구현, 확장하는 작업을 구체화라고 한다.

- 스타크래프트의 유닛을 예로 들어 추상 클래스와 추상 메서드 그리고 자손 클래스에서 이를 구현한 클래스까지 같이 만들어보자.

```java
package codefactory;

class Marine extends Unit {

    @Override
    void move(int x, int y) {
        System.out.println("마린 x = " + x + ", y = " + y + "로 이동");
    }
    
    void stimPack() {
        System.out.println("스팀팩 활성화");
    }
}

class Tank extends Unit {

    @Override
    void move(int x, int y) {
        System.out.println("탱크 x = " + x + ", y = " + y + "로 이동");
    }
    
    void changeMode() {
        System.out.println("시즈 탱크 모드 변경");
    }
}

public class UnitMain {
    public static void main(String[] args) {
        // 타입 묶음
        Unit[] units = {new Marine(), new Tank()};

        for (Unit unit : units) {
            unit.stop();
            unit.move(1, 2);
        }
    }
}
```

--- 

## 인터페이스란

- 인터페이스는 일종의 추상 클래스이다. 추상 클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버 변수를 구성원으로 가질 수 없다.

- 오직 추상 메서드와 상수만을 멤버로 가질 수 있다.

---

## 인터페이스의 작성

- 키워드로 class 대신 interface를 사용한다.

---

## 인터페이스의 상속

- 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중 상속, 즉 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다.

---

## 인터페이스의 구현

- 클래스는 확장한다는 의미의 키워드 `extends`를 사용하지만 인터페이스를 구현한다는 의미의 키워드 `implements`를 사용한다.

---

## 인터페이스를 이용한 다중상속


---

## 인터페이스를 이용한 다형성

- 자손 클래스의 인스턴스를 조상타입의 참조변수로 참조하는 것이 가능하다.

- 인터페이스 역시 이를 구현한 클래스의 조상이라 할 수 있으므로 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스 타입으로의 형변환도 가능하다.

- 인터페이스 Fightable을 클래스 Fighter가 구현했을 때, 다음과 같이 Fighter 인스턴스를 Fightable 인터페이스 타입의 참조변수로 참조하는 것이 가능하다.

```java
Fightable f = new Fighter();
```

- 따라서 인터페이스는 다음과 같이 메서드의 매개변수의 타입으로도 사용될 수 있다.

```java
void attack(Fightable f) {
   // ...
}
```

- 인터페이스 타입의 매개변수라는 의미는 해당 인터페이스를 구현한 구현체 클래스의 인스턴스를 매개변수로 제공해야 한다는 것이다.

- 또한 리턴 타입이 인터페이스 타입인 경우 메서드가 해당 인터페이스를 구현한 구현체 클래스의 인스턴스를 반환한다는 것이다.

---

## 인터페이스의 장점

- 개발 시간을 단축시킬 수 있다.

   - 인터페이스가 작성되면 이를 사용해서 프로그램을 작성하는 것이 가능하다. 메서드를 호출하는 쪽에서 메서드의 내용에 관계없이 선언부만 알면 되기 때문이다.
   - 동시에 다른 한 쪽에서는 인터페이스를 구현하는 구현체 클래스를 작성하게 하면, 인터페이스를 구현하는 클래스가 작성될 때까지 기다리지 않고도 양쪽에서 동시에 개발을 진행할 수 있다.
 
- 표준화가 가능하다.

   - 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램의 개발이 가능하다.
 
- 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.

   - 서로 상속관계에 있지도 않고 같은 조상 클래스를 가지고 있지 않은 아무런 연관없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어줄 수 있다.
 
- 독립적인 프로그래밍이 가능하다.

   - 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제 구현에 독립적인 프로그램을 작성하는 것이 가능하다.
   
   - 클래스와 클래스 간의 직적접인 관계를 인터페이스를 이용해서 간접적인 관계로 변경하면 한 클래스의 변경이 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다.   
 
---

