# BFS/DFS

탐색(Search)이란, 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 의미한다. 

DFS와 BFS를 제대로 이해하려면 기본 자료구조인 스택과 큐에 대한 이해가 전제되어야 하므로 스택과 큐, 재귀 함수를 간단히 정리하고자 한다.

자료구조(Data Structure)란, 데이터를 표현하고 관리하고 처리하기 위한 구조를 나타낸다. 그 중 스택과 큐는 자료구조의 기초 개념으로 다음의 두 핵심적인 함수로 구성된다.

- 삽입(Push) : 데이터를 삽입한다.

- 삭제(Pop) : 데이터를 삭제한다.

---

## 스택(Stack)

스택(Stack)은 박스 쌓기에 비유할 수 있다. 아래에 있는 박스를 꺼내기 위해선 위에 있는 박스부터 하나씩 꺼내야 한다.

이런 구조를 선입후출(FILO) 또는 후입선출(LIFO)구조라고 한다. 먼저 들어간 데이터가 가장 나중에 나온다는 의미다.

파이썬에서 스택을 이용할 때는 별도의 라이브러리가 필요 없다. 기본 리스트에서 append()와 pop()를 이용하면 스택 자료구조와 동일하게 동작한다.

append() 메서드는 리스트의 가장 뒤쪽에 데이터를 삽입하고 pop() 메서드는 리스트의 가장 뒤쪽에서 데이터를 꺼낸다.

---

## 큐(Queue)

큐(Queue)는 대기줄에 비유할 수 있다. 먼저 기다린 사람이 먼저 들어갈 수 있다는 것이다.

이런 구조를 선입선출(FIFO)구조라고 한다. 먼저 들어간 데이터가 먼저 나온다는 의미다.

파이썬에서 큐를 구현할 때는 collections모듈에 있는 deque 자료구조를 활용한다.

deque는 스택과 큐의 장점을 모두 채택한 것인데 데이터를 넣고 빼는 속도가 리스트 자료형에 비해 효율적이며 queue 라이브러리를 이용하는 것보다 간단하다.

deque객체를 리스트로 변경하고자 한다면 list() 메서드를 이용해 리스트 자료형으로 변경할 수 있다.

---

## 재귀 함수(Recursive Runction)

재귀 함수란, 자기 자신을 호출하는 함수를 말한다.

재귀 함수는 무한히 자기 자신을 호출하기 때문에 별도의 종료 조건을 명시하지 않으면 무한 호출되어 오류가 발생한다.

따라서, 재귀 함수를 사용할 때는 재귀 함수가 언제 끝날지를 종료 조건을 반드시 명시해야 한다.

컴퓨터 내부에서 재귀 함수의 수행은 스택 자료구조를 이용한다. 함수를 계속 호출했을 때 가장 마지막에 호출한 함수가 끝나야 그 전에 호출됐던 함수가 끝나기 때문이다.

---

## DFS(Depth-First-Search)

DFS(Depth-First-Search)는 깊이 우선 탐색이라고 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.

그래프는 노드(Node)와 간선(Edge)으로 표현되며 이 때, 노드를 정점(Vertex)이라고도 한다.

그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다. 또한 두 노드가 간선으로 연결되어 있다면 두 노드는 인접하다고 말한다.

프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있는데 코딩테스트에서는 이 두 방식 모두 필요하니 두 개념에 대해 잘 알고 있어야 한다.

- 인접 행렬(Adjacency Matrix) : 2차원 배열로 그래프의 연결 관계를 표현하는 방식

- 인접 리스트(Adjacency List) : 리스트로 그래프의 연결 관계를 표현하는 방식

DFS는 스택을 이용하는 알고리즘이기 때문에, 실제 구현은 재귀 함수를 이용했을 때 매우 간단하게 구현할 수 있다.

https://velog.io/@dnwls4659/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-DFS-%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89

---

## BFS(Breadth-First-Search)

BFS(Breadth-First-Search)는 너비 우선 탐색이라고 부르며, 가까운 노드부터 탐색하는 알고리즘이다.

DFS는 최대한 멀리 있는 노드를 우선으로 탐색한다면 BFS는 가까운 노드부터 탐색한다.

BFS는 큐 자료구조를 이용하는 것이 정석이다. 인접한 노드를 반복적으로 큐에 넣고 먼저 넣은 것이 먼저 나가게 되어 가까운 노드부터 탐색을 진행한다.

https://velog.io/@dnwls4659/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-BFS-%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89

---

### ▣ 실전 문제 : 음료수 얼려먹기

N x M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다.

구멍이 뚫려 있는 부분끼리 상하좌우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다.

이 때, 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오.

### ▣ 입력 조건

[1]. 첫째 줄에 얼음 틀이 세로 길이 N과 가로 길이 M이 주어진다.(1 ≤ N, M ≤ 1,000) 

[2]. 둘째 줄부터 N+1번째 줄까지 얼음 틀의 형태가 주어진다.

[3]. 이 때, 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.

### ▣ 출력 조건

한 번에 만들 수 있는 아이스크림의 개수를 출력한다.

### ▣ 입력 예시

5 4

00110

00011

11111

00000

### ▣ 출력 예시

3

```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
graph = [list(map(int, input().strip())) for _ in range(N)]

def DFS(y, x):
    # 종료 조건
    if y < 0 or y >= N or x < 0 or x >= M:
        return False
    if graph[y][x] == 0:
        graph[y][x] = 1
        DFS(y-1,x)
        DFS(y, x-1)
        DFS(y+1,x)
        DFS(y, x+1)
        return True
    return False

result = 0
for i in range(N):
    for j in range(M):
        if DFS(i, j):
            result += 1
print(result)
```

- 특정 지점의 상하좌우를 살펴본 뒤에 주변 지점 중에서 값이 0이면서 아직 방문하지 않았다면 DFS를 실행한다.

--- 

### ▣ 실전 문제 : 미로 탈출

동빈이는 N x M 크기의 직사각형 형태의 미로에 갇혀 있다. 미로에는 여러 마리의 괴물이 있어 이들을 피해 탈출해야 한다.

동빈이의 현 위치는 (1,1)이고 미로의 출구는 (N,M)의 위치에 존재하며 한 번에 한 칸씩만 이동할 수 있다.

이 때, 괴물이 있는 부분은 0으로, 괴물이 없는 부분은 1로 표시되어 있다.

미로는 반드시 탈출할 수 있는 형태로 제시된다. 이 때, 동빈이가 탈출하기 위해 움직여야 하는 최소 칸의 개수를 구하시오.

칸을 셀 때에는 시작 칸과 마지막 칸을 포함해서 계산한다.

### ▣ 입력 조건

[1]. 첫째 줄에 두 정수 N, M(4 ≤ N, M ≤ 200)이 주어집니다. 다음 N개의 줄에는 각각 M개의 정수(0 혹은 1)로 미로의 정보가 주어진다.

[2]. 각각의 수들은 공백 없이 붙어서 입력으로 제시된다. 또한 시작 칸과 마지막 칸은 항상 1이다.

### ▣ 출력 조건

첫째 줄에 최소 이동 칸의 개수를 출력하라.

### ▣ 입력 예시

5 6

101010

111111

000001

111111

111111

### ▣ 출력 예시

10

```python
import sys
input = sys.stdin.readline
from collections import deque

N, M = map(int, input().split())
graph = [list(map(int, input().strip())) for _ in range(N)]
visited = [[False] * M for _ in range(N)]
dy = [1, 0, -1, 0]
dx = [0, 1, 0, -1]

def BFS(a, b):
    q = deque()
    q.append((a, b))
    visited[a][b] = True
    while q:
        y, x = q.popleft()
        for i in range(4):
            ny = y + dy[i]
            nx = x + dx[i]
            if 0 <= ny < N and 0 <= nx < M and graph[ny][nx] == 1 and not visited[ny][nx]:
                graph[ny][nx] = graph[y][x] + 1
                visited[ny][nx] = True
                q.append((ny, nx))
    return graph[N-1][M-1]

print(BFS(0, 0))
```

- 그래프의 정보를 나타내는 2차원 배열과 방문 여부를 확인하는 2차원 배열을 만든다.

- 상하좌우 모두 탐색하여 괴물이 없으면서 방문하지 않은 곳이라면 그곳으로 이동을 한다.

- 마지막 (N, M) 좌표에 도달했다면 그 때 값을 리턴한 후 출력한다.
