# 그리디(Greedy)

그리디 알고리즘은 단순하지만 강력한 문제 해결 방법으로 **탐욕법**이라고도 한다.

그리디 알고리즘의 가장 중요한 핵심은 **지금 현재 주어진 상황에서 가장 좋은 선택지만을 고르는 것**이다.

---

### ▣ 예제 3-1. 거스름돈

Q. 문제 설명

당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다.

손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러 줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.

```python
import sys
input = sys.stdin.readline

N = int(input())
coin = 0
coin_list = [500, 100, 50, 10]

for i in coin_list:
    if N == 0:
        break
    else:
        coin += N // i
        N %= i
print(coin)
```

A. 답안 설명

코드를 보면 `coin_list`에 거스름돈의 액면가를 담는 배열이 있고 이 배열의 원소의 개수에 의해 시간 복잡도가 결정이 된다. 

따라서 화폐의 종류의 개수를 K라고 할 때, 시간 복잡도는 O(K)이다. 돈의 액면가는 시간 복잡도에 영향을 미치지 않는다는 것을 알 수 있다.

### ▣ 그리디 알고리즘의 정당성

그리디 알고리즘을 모든 알고리즘 문제에 적용할 수 있는 것은 아니다.

대부분의 문제는 그리디 알고리즘을 이용했을 때 `최적의 해`를 찾을 수 없을 가능성이 다분하다.

위의 거스름돈 예시에서 하나 체크할 부분이 있는데 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.

만약 800원을 거슬러 줘야 하고 화폐의 종류로 500원, 400원, 100원이 있다고 가정하면 이 때 이 문제를 그리디 알고리즘으로 접근하면 결과는 500원 1개, 100원 3개로 총 동전의 개수는 4개가 된다.

하지만 이를 추후 학습할 다이나믹 프로그래밍으로 접근하면 결과는 400원 2개라는 결과가 나온다.

따라서 모든 문제풀이에 바로 그리디 알고리즘을 적용하기보다는 고민하면서 어떤 접근 방식이 효율적인지를 깊게 생각해봐야 한다.

---

### ▣ 실전 문제 : 큰 수의 법칙

'큰 수의 법칙'은 일반적으로 통계 분야에서 다루어지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 있다.

동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다.

단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없다는 것이 이 법칙의 특징이다. 

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.

### ▣ 입력 조건

[1]. 첫째 줄에 N(2 ≤ N ≤ 1,000), M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.

[2]. 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1이상 10,000이하의 자연수로 주어진다.

[3]. 입력으로 주어지는 K는 항상 M보다 작거나 같다.

### ▣ 출력 조건

첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력하세요.

### ▣ 입력 예시

5 8 3

2 4 5 4 6

### ▣ 출력 예시

46

```python
import sys
input = sys.stdin.readline

N, M, K = map(int, input().split())
arr = list(map(int, input().split()))

arr.sort(reverse=True)
first = arr[0]
second = arr[1]

ans = 0
temp = K
for i in range(M):
    if temp == 0:
        ans += second
        temp = K 
    else:
        temp -= 1
        ans += first
print(ans)
```

- M번의 덧셈을 수행하되 연속으로 K번을 초과하지 않도록 덧셈을 수행하여 최댓값을 도출하는 것이 핵심이라고 생각한다.

- 가장 큰 수를 K번 더한 후 K가 0이라면 그 다음으로 가장 큰 수를 더해주면 되고 다시 가장 큰 수를 더하는 방식으로 접근할 수 있다.

- 이 문제의 M의 크기가 매우 큰 값이 주어진다면 정렬과 for문 순회에서 시간이 많이 소요되어 시간 초과 판정을 받게 된다.

- 규칙성을 파악하면 아래와 같은 최적화된 코드로 작성하는 것이 가능하다.

```python
import sys
input = sys.stdin.readline

N, M, K = map(int, input().split())
arr = list(map(int, input().split()))

arr.sort(reverse=True)
first = arr[0]
second = arr[1]

count = (M // (K + 1)) * K + (M % (K + 1))

result = 0
result += count * first
result += (M - count) * second
print(result)
```

- 반복되는 수열의 길이를 이용하면 위와 같이 가장 큰 수를 몇 번 더해야하는지와 그 다음으로 큰 수를 몇 번 더하는지 확인하여 구할 수 있다.

- 이 때, 변수 `count`를 위와 같이 정의한 이유는 M이 (K+1)로 나누어 떨어지지 않는 경우도 고려해야하기 때문이다.

- 예를 들어, 위의 문제에 주어진 테스트케이스에서 M을 7로 바꿨을 경우 '6 + 6 + 6 + 5 + 6 + 6 + 6'이 최종 결과가 되는데 M // (K+1)을 해주면 값이 1이 나오게 되는데 그렇게 되면 가장 큰 수를 더해줘야하는 횟수가 차감이 되어 나타난다.

- 가장 큰 수를 더해줘야 하는 횟수를 구해준 다음 전체 M번의 연산 횟수에서 count를 뺀 횟수만큼을 그 다음으로 큰 수와 곱해 값을 더해주면 된다.

---

### ▣ 실전 문제 : 숫자 카드 게임

숫자 카드 게임은 여러 개의 숫자 카드 중에서 가장 높은 숫자가 스인 카드 한 장을 뽑는 게임이다.

단, 게임의 룰을 지키며 카드를 뽑아야 하는데 그 룰은 다음과 같다.

```bash
[1]. 숫자가 쓰인 카드들이 N × M 형태로 놓여 있다. 이 때, N은 행의 개수를 의미하며, M은 열의 개수를 의미한다.

[2]. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.

[3]. 그 다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다.

[4]. 따라서 처음에 카드를 골라낼 행을 선택할 때 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑는 것을 고려하여 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.
```

### ▣ 입력 조건

[1]. 첫째 줄에 숫자 카드들이 놓인 행의 개수 N과 열의 개수 M이 공백을 기준으로 각각 자연수로 주어진다.(1 ≤ N, M ≤ 100)

[2]. 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1이상 10,000이하의 자연수이다.

### ▣ 출력 조건

첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다.

### ▣ 입력 예시1

3 3

3 1 2

4 1 4

2 2 2

### ▣ 출력 예시1

2

### ▣ 입력 예시2

2 4

7 3 1 8

3 3 3 4

### ▣ 출력 예시2

3

```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]

min_list = [min(row) for row in arr]
print(max(min_list))
```

- min()을 이용하거나 2중 반복문을 이용하는 방법이 있고 어떤 방법을 이용해서 풀더라도 무방하다.

- 여기서 코드를 좀 더 간결하게 작성하기 위해 리스트 컴프리헨션을 사용했다. 이 부분에도 주목하자.

 ---

### ▣ 실전 문제 : 1이 될 때까지

어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다.

단, 두 번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.

```bash
[1]. N에서 1을 뺀다.

[2]. N을 K로 나눈다.
```

N과 K가 주어질 때, N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하시오.

### ▣ 입력 조건

[1]. 첫째 줄에 N(2 ≤ N ≤ 100,000)과 K(2 ≤ K ≤ 100,000)가 공백으로 구분되며 각각 자연수로 주어진다. 

[2]. 이 때, 입력으로 주어지는 N은 항상 K보다 크거나 같다.

### ▣ 출력 조건

첫째 줄에 N이 1이 될 때까지 1번 혹은 2번의 과정을 수행해야 하는 최소 횟수를 출력한다.

### ▣ 입력 예시

25 5

### ▣ 출력 예시

2

```python
import sys
input = sys.stdin.readline

N, K = map(int, input().split())
count = 0

while N != 1:
    if N % K == 0:
        N //= K
    else:
        N -= 1
    count += 1
print(count)
```

- 문제에서의 N의 범위가 100,000이하이므로 이처럼 일일이 1씩 빼도 문제를 해결할 수 있지만 N이 100억 이상의 큰 수가 되는 경우를 가정했을 때에도 빠르게 동작하려면 N이 K의 배수가 될 수 있도록 효율적으로 한 번에 빼는 방식으로도 작성할 수 있다.

```python
import sys
input = sys.stdin.readline

N, K = map(int, input().split())
result = 0

while True:
    target = (N // K) * K   # N이 K로 나뉠 수 있을 때까지 1을 빼는 방법
    result += (N - target)  # 1을 빼줘야하는 횟수
    N = target
    if N < K:
        break
    result += 1
    N //= K

result += (N-1) # 마지막으로 남은 수(N < K인 경우 무한루프 탈출하고 남은 수)에 대하여 1씩 빼기
print(result)
```
