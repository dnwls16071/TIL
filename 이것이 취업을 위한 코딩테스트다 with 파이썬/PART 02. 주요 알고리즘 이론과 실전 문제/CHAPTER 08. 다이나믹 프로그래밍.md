# 다이나믹 프로그래밍(Dynamic Programming)

피보나치 수열은 대표적인 다이나믹 프로그래밍 알고리즘의 대표 문제다.

이 피보나치 수열을 풀 때 두 가지 방법을 적용할 수 있는데 이 때 **탑다운**(**Top-Down**)과 **바텀업**(**Bottom-Up**)이라는 개념이 도입된다.

---

## 메모이제이션(Memoization) 기법을 사용한 방법

메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중의 하나로 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출했을 때, 메모한 결과(이미 계산된 적 있다면)를 그대로 가져오는 기법을 말한다.

메모이제이션은 값을 저장하는 방법이므로 캐싱이라고도 한다.

<img width="653" alt="images_hwaya2828_post_2ddd0405-d078-4d41-b2a0-10d4b2f7ab9a_스크린샷 2021-08-13 오후 12 02 05" src="https://github.com/dnwls16071/TIL/assets/106802375/c7301d34-a0f6-4b32-a893-d1a3fbaf2b32">

fibonacci(6)을 호출할 때의 변화를 나타낸 이미지이다.

이렇게 **재귀 함수를 이용하여 다이나믹 프로그래밍 소스 코드를 작성하는 방법**을,  큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 탑다운(Top-Down) 방식이라고 한다.

```python
import sys
input = sys.stdin.readline

dp = [0] * 100

def fibonacci(x):
    if x == 1 or x == 2:
        return 1
    if dp[x] != 0:
        return dp[x]
    dp[x] = fibonacci(x-1) + fibonacci(x-2)
    return dp[x]

result = fibonacci(6)
print(result)
```

---

## 반복문을 이용한 방법

위의 방법은 큰 문제를 해결하기 위해 작은 문제를 호출하는 방법이었고 이번에 설명할 방법은 단순 반복문을 이용하여 작은 문제부터 답을 도출해 원하는 결론을 도출하는 방법으로 바텀업(Bottom-Up) 방식이라고 한다.

```python
import sys
input = sys.stdin.readline

dp = [0] * 100

dp[1] = 1
dp[2] = 1
for i in range(3, 100):
    dp[i] = dp[i-1] + dp[i-2]
print(dp)
```

탑다운(Top-Down) 방법과 바텀업(Bottom-Up) 방법 두 가지를 모두 알아보았는데 가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 바텀업 방식으로 구현하는 것을 권장한다.

시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다. 실제로 위에서 작성한 재귀적인 피보나치 수열의 소스코드에서 5000번째 이상의 피보나치 수를 구하려고 하면 `recursion depth`, 최대 재귀 깊이와 관련되 에러가 발생할 수 있기 때문이다.

이 경우 sys라이브러리에 포함되어 있는 setrecursionlimit() 함수를 호출하여 재귀 제한을 완화할 수 있다는 점 정도만 기억하자.

---

### ▣ 실전 문제 : 1로 만들기

정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지가 있다.

```bash
ⓐ. X가 5로 나누어떨어지면 5로 나눈다.

ⓑ. X가 3으로 나누어떨어지면 3으로 나눈다.

ⓒ. X가 2로 나누어떨어지면 2로 나눈다.

ⓓ. X에서 1을 뺀다.
```

정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

### ▣ 입력 조건

[1]. 첫째 줄에 정수 X가 주어진다.(1 ≤ X ≤ 30,000)

### ▣ 출력 조건

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

### ▣ 입력 예시

26

### ▣ 출력 예시

3

```python
import sys
input = sys.stdin.readline

N = int(input())
dp = [0] * 30001

for i in range(2, N+1):
    # 1을 빼는 연산
    dp[i] = dp[i-1] + 1
    # 2로 나누는 연산
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i // 2] + 1)
    # 3으로 나누는 연산
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i // 3] + 1)
    # 5로 나누는 연산
    if i % 5 == 0:
        dp[i] = min(dp[i], dp[i // 5] + 1)
print(dp[N])
```

---

### ▣ 실전 문제 : 개미 전사

개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다.

메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일직선으로 이어져 있다. 각 식량창고에는 정해진 수의 식량을 저장하고 있으며 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다.

이 때, 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다.

따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다.

예를 들어 식량창고 4개가 다음과 같이 존재한다고 가정하자.

```bash
[1, 3, 1, 5]
```

이 때, 개미 전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있다.

개미 전사는 식량창고가 이렇게 일직선상일 때 최대한 많은 식량을 얻기를 원한다.

개미 전사를 위해 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그램을 작성하시오.

### ▣ 입력 조건

[1]. 첫째 줄에 식량창고의 개수 N이 주어진다.(3 ≤ N ≤ 100)

[2]. 둘째 줄에 공백으로 구분되어 각 식량창고에 저장된 식량의 개수 K가 주어진다.(0 ≤ K ≤ 1,000)

### ▣ 출력 조건

첫째 줄에 개미 전사가 얻을 수 있는 식량의 최댓값을 출력하시오.

### ▣ 입력 예시

4

1 3 1 5

### ▣ 출력 예시

8

```python
import sys
input = sys.stdin.readline

N = int(input())
arr = [0] + list(map(int, input().split()))
dp = [0] * (N+1)
# 첫 번째 식량 창고 ▶ 첫 번째 식량창고를 털 때 최댓값이 나옴
dp[1] = arr[1]
# 두 번째 식량 창고 ▶ 첫 번째 식량창고를 털 것인지 아니면 두 번째 식량창고를 털 것인지
dp[2] = max(arr[2], arr[1])


for i in range(3, N+1):
    # i번째 최댓값 : (i-1)번째 식량창고를 털었을 때 식량창고의 양 vs (i-2)번째 식량창고를 털고 i번째 식량창고까지 턴 양의 합
    dp[i] = max(dp[i-2] + arr[i], dp[i-1])
print(dp[N])
```

---

### ▣ 실전 문제 : 바닥 공사

가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥이 있다. 태일이는 이 얇은 바닥을 1 x 2의 덮개, 2 x 1의 덮개, 2 x 2의 덮개를 이용해서 채우고자 한다.

이 때, 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오. 예를 들어 2 x 3 크기의 바닥을 채우는 경우의 수는 5가지이다.

### ▣ 입력 조건

[1]. 첫째 줄에 N이 주어진다.(1 ≤ N ≤ 1,000)

### ▣ 출력 조건

첫째 줄에 2 x N 크기의 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지를 출력한다.

### ▣ 입력 예시

3

### ▣ 출력 예시

5

```python
import sys
input = sys.stdin.readline

N = int(input())

dp = [0] * 1001

dp[1] = 1
dp[2] = 3
for i in range(3, N+1):
    dp[i] = (dp[i-1] + dp[i-2] * 2) % 796796
print(dp[N])
```

- (i-1)번째까지 타일을 채우는 경우의 수와 (i-2)번째까지 타일을 채우는 경우의 수를 고려한다.

- (i-1)번째까지 타일을 채우는 경우 남은 한 칸은 2 x 1 크기의 타일 2장으로 채우는 1가지만 존재한다.

- (i-2)번째까지 타일을 채우는 경우 남은 두 칸은 2 x 2 크기의 타일로 채우는 경우와 1 x 2 크기의 타일 2장으로 채우는 경우 총 2가지가 존재한다. 이 때, 2 x 1 크기의 타일 2장으로 채우는 경우는 (i-1)번째까지 타일을 채우는 경우에 포함되므로 중복해서 계산하면 안되기 때문에 이 경우에선 배제해야 한다.

---

### ▣ 실전 문제 : 효율적인 화폐 구성

N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다.

이 때, 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서가 다른 것은 같은 경우로 간주한다.

예를 들어, 2원, 3원 단위의 화폐가 있을 때, 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.

### ▣ 입력 조건

[1]. 첫째 줄에 N, M이 주어진다.(1 ≤ N ≤ 100, 1 ≤ M ≤ 10,000)

[2]. 이후 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐 가치는 10,000보다 작거나 같은 자연수이다.

### ▣ 출력 조건

첫째 줄에 M원을 만들기 위한 최소한의 화폐 개수를 출력한다. 불가능할 때는 -1을 출력한다.

### ▣ 입력 예시

2 15

2

3

### ▣ 출력 예시

5

```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
INF = 1e6

dp = [INF] * 10001
dp[0] = 0
coins = []
for _ in range(N):
    coins.append(int(input()))

for coin in coins:
    for i in range(coin, M+1):
        dp[i] = min(dp[i], dp[i-coin] + 1)

if dp[M] == INF:
    print(-1)
else:
    print(dp[M])
```

