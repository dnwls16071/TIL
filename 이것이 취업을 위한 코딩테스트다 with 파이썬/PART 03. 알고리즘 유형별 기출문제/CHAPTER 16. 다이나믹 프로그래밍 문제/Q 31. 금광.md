### 📌문제 설명

n x m 크기의 금광이 있습니다. 금광은 1 x 1 크기의 칸으로 나누어져 있으며, 각 칸은 특정한 크기의 금이 들어 있습니다.

채굴자는 첫 번째 열부터 출발하여 금을 캐기 시작합니다. 맨 처음에는 첫 번째 열의 어느 행에서든 출발할 수 있습니다.

이후에 m - 1번에 걸쳐서 매번 오른쪽 위, 오른쪽, 오른쪽 아래 3가지 중 하나의 위치로 이동해야 합니다.

결과적으로 채굴자가 얻을 수 있는 금의 최대 크기를 출력하는 프로그램을 작성하세요.

### 📌입력 조건

첫째 줄에 테스트 케이스 T가 입력됩니다. (1 ≤ T ≤ 1000) 매 테스트 케이스 첫째 줄에 n과 m이 공백으로 구분되어 입력됩니다. (1 ≤ n, m ≤ 20)

둘째 줄에 n x m개의 위치에 매장된 금의 개수가 공백으로 구분되어 입력됩니다. (1 ≤ 각 위치에 매장된 금의 개수 ≤ 100)

### 📌출력 조건

테스트 케이스마다 채굴자가 얻을 수 있는 금의 최대 크기를 출력합니다. 각 테스트 케이스는 줄 바꿈을 이용해 구분합니다.

### 📌입력 예시

```
2
3 4
1 3 3 2 2 1 4 1 0 6 4 7
4 4
1 3 1 5 2 2 4 1 5 0 2 3 0 6 1 2
```

### 📌출력 예시

```
19
16
```

### 📌소스 코드

```python
import sys, copy
input = sys.stdin.readline

T = int(input())
for _ in range(T):
    dp = []
    n, m = map(int, input().split())
    lst = list(map(int, input().split()))

    idx = 0
    for i in range(len(lst) // m):
        dp.append(lst[idx:idx+m])
        idx += m
    array = copy.deepcopy(dp)

    for i in range(1, m):
        for j in range(n):
            # 맨 처음 행일 때
                # 왼쪽
                # 왼쪽 아래 
            if j == 0:
                dp[j][i] = array[j][i] + max(dp[j][i-1], dp[j+1][i-1])
            # 맨 마지막 행일 때
                # 왼쪽
                # 왼쪽 위
            elif j == n-1:
                dp[j][i] = array[j][i] + max(dp[j][i-1], dp[j-1][i-1])
            # 중간 행일 때
                # 왼쪽 위
                # 왼쪽
                # 왼쪽 아래
            else:
                dp[j][i] = array[j][i] + max(dp[j][i-1], dp[j-1][i-1], dp[j+1][i-1])
    
    result = 0
    for i in range(n):
        result = max(result, dp[i][m-1])
    print(result)
```

### 📌문제 접근

[1]. 책의 풀이를 생각하지 못했고 원본 배열을 깊은 복사처리한 배열을 별도로 만들어 dp테이블과 같이 사용하는 방법으로 해결했다.
