### 📌문제 설명

때는 2040년, 이민혁은 우주에 자신만의 왕국을 만들었다. 왕국은 N개의 행성으로 이루어져 있다. 민혁이는 이 행성을 효율적으로 지배하기 위해서 행성을 연결하는 터널을 만들려고 한다.

행성은 3차원 좌표위의 한 점으로 생각하면 된다. 두 행성 A(xA, yA, zA)와 B(xB, yB, zB)를 터널로 연결할 때 드는 비용은 min(|xA-xB|, |yA-yB|, |zA-zB|)이다.

민혁이는 터널을 총 N-1개 건설해서 모든 행성이 서로 연결되게 하려고 한다. 이때, 모든 행성을 터널로 연결하는데 필요한 최소 비용을 구하는 프로그램을 작성하시오.

### 📌입력 조건

첫째 줄에 행성의 개수 N이 주어진다. (1 ≤ N ≤ 100,000) 다음 N개 줄에는 각 행성의 x, y, z좌표가 주어진다. 좌표는 -109보다 크거나 같고, 109보다 작거나 같은 정수이다. 한 위치에 행성이 두 개 이상 있는 경우는 없다. 

### 📌출력 조건

첫째 줄에 모든 행성을 터널로 연결하는데 필요한 최소 비용을 출력한다.

### 📌입력 예시

```
5
11 -15 -15
14 -5 -15
-1 -1 -5
10 -4 -1
19 -4 19
```

### 📌출력 예시

```
4
```

### 📌소스 코드

```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**8)

def findParent(parent, x):
    if parent[x] != x:
        parent[x] = findParent(parent, parent[x])
    return parent[x]

def unionParent(parent, a, b):
    a = findParent(parent, a)
    b = findParent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

N = int(input())
parent = [0] * (N+1)
for i in range(1, N+1):
    parent[i] = i

location = []
# i는 행성의 번호(루트 노드 찾을 때 쓰려고)
for i in range(N):
    a, b, c = map(int, input().split())
    location.append((a, b, c, i))

loc_x = sorted(location, key=lambda x : x[0])
loc_y = sorted(location, key=lambda x : x[1])
loc_z = sorted(location, key=lambda x : x[2])

edges = []
# edge = (distance, node1, node2)
for i in range(N-1):
    edge = ((abs(loc_x[i][0] - loc_x[i+1][0])), loc_x[i][3], loc_x[i+1][3]) 
    edges.append(edge)
for i in range(N-1):
    edge = ((abs(loc_y[i][1] - loc_y[i+1][1])), loc_y[i][3], loc_y[i+1][3])
    edges.append(edge)
for i in range(N-1):
    edge = ((abs(loc_z[i][2] - loc_z[i+1][2])), loc_z[i][3], loc_z[i+1][3])
    edges.append(edge)

edges.sort()    

total = 0
for edge in edges:
    distance, a, b = edge
    if findParent(parent, a) != findParent(parent, b):
        unionParent(parent, a, b)
        total += distance
print(total)
```

### 📌문제 접근

[1]. 모든 행성들의 경우를 전부 비교하여 비용이 최소가 되는 경우를 계산한다면 `N x (N-1) / 2`의 계산 횟수가 필요하다.

[2]. N의 최댓값이 100,000이고 위와 같이 전부 비교한다면 2중 for문을 활용해야하는데 `O(N^2)`이 되어 메모리 초과가 발생하게 된다는 사실을 예측할 수 있다.

[3]. 각 좌표를 기준으로 정렬(x, y, z좌표 기준)하여 최소가 되는 경우를 찾는다.

![img1 daumcdn](https://github.com/dnwls16071/TIL/assets/106802375/255d693d-0435-48a9-9ec8-8c3c5c39ff98)

